<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[基于Vuejs、vue-router、iview的管理后台]]></title>
      <url>http://zhangshuang.top/%E5%9F%BA%E4%BA%8EVuejs%E3%80%81vue-router%E3%80%81iview%E7%9A%84%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0/</url>
      <content type="html"><![CDATA[<p>上一篇分享的是使用angularjs及materialdesign的管理后台前端页面的实现。因为感觉input的输入框实在是太丑了，并且用户端的页面我早已开发完毕，就等着后端给接口了，所以就萌生出了使用心中一直念念不忘的Vuejs来实现一版管理后台。<br><a id="more"></a><br>这个使用了Vue-cli来构建vue架构，使用vue-router来搭建路由，使用iview来作为UI框架。</p>
<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><ol>
<li><p>安装nodejs<br><a href="http://blog.zhangshuang.top/nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" target="_blank" rel="external">nodejs安装及常用快捷键</a><br>建议安装nvm来控制nodejs的版本，上面的链接里有详细的步骤，包括启动node服务常用的PM2等等…</p>
</li>
<li><p>全局安装webpack、vue-cli脚手架<br><code>npm install -g webpack vue-cli</code>;</p>
</li>
<li><p>创建工程<br><code>vue init webpack-simple &lt;project name&gt;</code><br>这里直接一路回车就可以了。<br>注意：工程名不能是中文</p>
</li>
<li><p>安装项目依赖<br>进入工程，输入<code>npm install</code>就可以了。</p>
</li>
<li><p>安装路由模块vue-router、网络请求模块vue-resource模块<br><code>npm install --save vue-router vue-resource</code><br>这个会安装到<code>package.json</code>的<code>dependencies</code>中。</p>
</li>
<li><p>安装UI框架 iView<br><code>npm install --save iview</code></p>
</li>
<li><p>使用iView、vue-router、vue-resource</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line"># main.js</div><div class="line">import Vue from &apos;vue&apos;;</div><div class="line">import VueRouter from &apos;vue-router&apos;;</div><div class="line">import VueResource from &apos;vue-resource&apos;;</div><div class="line">import iview from &apos;iview&apos;;</div><div class="line">import &apos;iview/dist/styles/iview.css&apos;;</div><div class="line">import App from &apos;./App.vue&apos;;</div><div class="line"></div><div class="line">Vue.config.debug = true;</div><div class="line">Vue.use(VueRouter);</div><div class="line">Vue.use(VueResource);</div><div class="line">Vue.use(iview);</div></pre></td></tr></table></figure>
</li>
<li><p>修改webpack.config.js配置文件<br>因为使用iView需要引用其css，但是最初的webpack.config.js文件里面并没有配置读取css文件和字体文件或者有的设定的有问题，所以这里需要我们自行修改一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    test: /\.js$/,</div><div class="line">    loader: &apos;babel-loader&apos;,</div><div class="line">    exclude: /node_modules/</div><div class="line"> &#125;,</div><div class="line"> &#123;</div><div class="line">    test: /\.css$/,</div><div class="line">    loader: &quot;style-loader!css-loader&quot;</div><div class="line"> &#125;,</div><div class="line"> &#123;</div><div class="line">    test: /\.(eot|woff|woff2|ttf)([\\?]?.*)$/,</div><div class="line">    loader: &quot;file-loader&quot;</div><div class="line"> &#125;,</div><div class="line"> &#123;</div><div class="line">    test: /\.(png|jpg|gif|svg)$/,</div><div class="line">    loader: &apos;file-loader&apos;,</div><div class="line">    options: &#123;</div><div class="line">      name: &apos;[name].[ext]?[hash]&apos;</div><div class="line">    &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>完整的配置如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var path = require(&apos;path&apos;);</div><div class="line">var webpack = require(&apos;webpack&apos;);</div><div class="line"></div><div class="line">module.exports = &#123;</div><div class="line">  entry: &apos;./src/main.js&apos;,</div><div class="line">  output: &#123;</div><div class="line">    path: path.resolve(__dirname, &apos;./dist&apos;),</div><div class="line">    publicPath: &apos;/dist/&apos;,</div><div class="line">    filename: &apos;build.js&apos;</div><div class="line">  &#125;,</div><div class="line">  module: &#123;</div><div class="line">    loaders: [</div><div class="line">      &#123;</div><div class="line">        test: /\.vue$/,</div><div class="line">        loader: &apos;vue-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          loaders: &#123;</div><div class="line">          &#125;</div><div class="line">          // other vue-loader options go here</div><div class="line">        &#125;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.js$/,</div><div class="line">        loader: &apos;babel-loader&apos;,</div><div class="line">        exclude: /node_modules/</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.css$/,</div><div class="line">        loader: &quot;style-loader!css-loader&quot;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.(eot|woff|woff2|ttf)([\\?]?.*)$/,</div><div class="line">        loader: &quot;file-loader&quot;</div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        test: /\.(png|jpg|gif|svg)$/,</div><div class="line">        loader: &apos;file-loader&apos;,</div><div class="line">        options: &#123;</div><div class="line">          name: &apos;[name].[ext]?[hash]&apos;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  resolve: &#123;</div><div class="line">    alias: &#123;</div><div class="line">      &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;,</div><div class="line">    &#125;</div><div class="line">  &#125;,</div><div class="line">  devServer: &#123;</div><div class="line">    historyApiFallback: true,</div><div class="line">    noInfo: true</div><div class="line">  &#125;,</div><div class="line">  performance: &#123;</div><div class="line">    hints: false</div><div class="line">  &#125;,</div><div class="line">  devtool: &apos;#eval-source-map&apos;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">if (process.env.NODE_ENV === &apos;production&apos;) &#123;</div><div class="line">  module.exports.devtool = &apos;#source-map&apos;;</div><div class="line">  // http://vue-loader.vuejs.org/en/workflow/production.html</div><div class="line">  module.exports.plugins = (module.exports.plugins || []).concat([</div><div class="line">    new webpack.DefinePlugin(&#123;</div><div class="line">      &apos;process.env&apos;: &#123;</div><div class="line">        NODE_ENV: &apos;&quot;production&quot;&apos;</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    new webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">      sourceMap: true,</div><div class="line">      compress: &#123;</div><div class="line">        warnings: false</div><div class="line">      &#125;</div><div class="line">    &#125;),</div><div class="line">    new webpack.LoaderOptionsPlugin(&#123;</div><div class="line">      minimize: true</div><div class="line">    &#125;)</div><div class="line">  ]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ol>
<li>启动项目<br><code>npm run dev</code></li>
</ol>
<h2 id="UI框架-iView"><a href="#UI框架-iView" class="headerlink" title="UI框架 iView"></a>UI框架 iView</h2><p>因为之前angular项目的经历，所以在UI框架的选择中，就很是花了一番心思。最初打算使用element，后来从ant-design的官网上看到了iview，读了读作者的简介之后深有感触，感觉UI确实看起来不错，所以就选择了这个框架。<br>这个UI框架因为是国人弄的，所以看起来基本就是0难度，上手非常容易。需要的样式都可以从官网的demo中找到。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>通过import引入iview，并且调用<code>vue.use()</code>方法即可使用iView框架。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import iview from &apos;iview&apos;;</div><div class="line">vue.use(iview);</div></pre></td></tr></table></figure></p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>iview的布局是通过<code>Row</code>、<code>Col</code>标签实现的，但是<code>Col</code>标签必须位于<code>Row</code>标签里面。它的栅格化布局把页面分为了24份。通过给变迁添加<code>span</code>属性就可以实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;Row&gt;</div><div class="line">    &lt;Col span=&quot;22&quot;&gt;</div><div class="line">        &lt;Icon type=&quot;ios-paper&quot; size=&quot;40&quot;&gt;&lt;/Icon&gt;</div><div class="line">        &lt;h3&gt;活动管理&lt;/h3&gt;</div><div class="line">    &lt;/Col&gt;</div><div class="line">    &lt;Col span=&quot;2&quot; class=&quot;activity-manager-button-add&quot;&gt;</div><div class="line">        &lt;Button type=&quot;primary&quot;&gt;活动&lt;/Button&gt;</div><div class="line">    &lt;/Col&gt;</div><div class="line">&lt;/Row&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Icon"><a href="#Icon" class="headerlink" title="Icon"></a>Icon</h4><p>合理的使用icon可以使项目变得好看一些，通过给iview中的Icon标签设置type属性，就可以显示出icon图片来。iview提供了很多icon，虽然已手机类的居多，但是还是能找到相似的使用的。设置size属性就可以改变icon的大小。</p>
<h4 id="table"><a href="#table" class="headerlink" title="table"></a>table</h4><p>之前的angular项目中，table是自己写的，但是发现iview中table效果很棒，所以直接就用的iview的Table标签。<br><code>&lt;Table :columns=&quot;activityTable&quot; :data=&quot;activityList&quot;&gt;&lt;/Table&gt;</code><br>template中只需要这一行就可以设置好table，columns属性是设置table的表头，</p>
<h6 id="Issue"><a href="#Issue" class="headerlink" title="Issue:"></a>Issue:</h6><p>Table表单暂时不能在变化宽度的时候自适应，暂时还未开放宽度设定接口。</p>
<h4 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h4><p>iview的Button样式也很好看，通过设置<code>type</code>属性就可以设置不同的样式，<code>disable</code>属性可以控制是否可以点击。</p>
<h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p>全部功能可以从官网上找到，上手非常简单，基本看一眼就会<a href="https://www.iviewui.com" target="_blank" rel="external">iView官网</a></p>
<h2 id="路由-vue-router"><a href="#路由-vue-router" class="headerlink" title="路由 vue-router"></a>路由 vue-router</h2><p>路由用的是官方支持的<a href="http://vuejs.github.io/vue-router/" target="_blank" rel="external">vue-router</a>。<br>如果要在一个模块化工程中使用vue-router，需要使用<code>vue.use()</code>方法，用以安装路由功能。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import VueRouter from &apos;vue-router&apos;;</div><div class="line">vue.use(VueRouter);</div></pre></td></tr></table></figure></p>
<h4 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h4><p>template中，路由通过<code>router-link</code>标签来使用，设置<code>to</code>属性可以设置跳转位置：<br><code>&lt;router-link :to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt;</code>，这个在项目运行时，会渲染成<code>&lt;a href=&quot;&quot;&gt;&lt;/a&gt;</code><br>跟AngularJs一样，Vuejs也需要一个类似于<code>ng-view</code>的东西来放置替换进来的template。<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p>
<h4 id="Js"><a href="#Js" class="headerlink" title="Js"></a>Js</h4><p>在创建路由之前，需要先把要使用的模块引入，当然也可以从本文件创建一个，不过这不太符合组件化的初衷。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import home from &apos;./component/home.vue&apos;;</div><div class="line">import about from &apos;./component/about.vue&apos;;</div></pre></td></tr></table></figure></p>
<p>引入模块之后，需要定义路由，并且创建一个VueRouter的实例。这里通过一步来完成这个过程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">    base: __dirname,</div><div class="line">    routes: [</div><div class="line">        &#123;path: &apos;/home&apos;, component: home&#125;,</div><div class="line">        &#123;path: &apos;/about&apos;, component: about&#125;</div><div class="line">    ]</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>最后要把VueRouter挂载到应用中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const app = new Vue(&#123;</div><div class="line">    router</div><div class="line">&#125;).$mount(&apos;#app&apos;);</div></pre></td></tr></table></figure></p>
<h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><p>就像restful风格一样，有些内容会重复使用同一个模块。比如有多个user，共同使用user.vue这个组件模块，那么我们就可以在router中使用动态路径参数来实现这个效果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;/pollConfig/:pollid&apos;,</div><div class="line">    component: pollConfig</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中，<code>:pollid</code>就是动态的，像<code>/pollConfig/1</code>、<code>/pollConfig/2</code>都能通过上面的路由，匹配到<code>pollConfig</code>这个组件。</p>
<h4 id="Js中使用路由"><a href="#Js中使用路由" class="headerlink" title="Js中使用路由"></a>Js中使用路由</h4><p>如果我们想实现在js中进行跳转，如<code>window.location.href</code>这种效果时，通过设置<code>this.$router.push()</code>就可以实现：<br><code>this.$router.push({path: &#39;/home&#39;})</code><br>除了<code>push</code>以外还有几种方法，这个跟h5的history的API比较像</p>
<h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>举一个例子来说，如果我们访问<code>/home</code>这个路由时，访问到的是<code>home</code>这个组件模块，但是我们在直接访问这个网站的时候，一般路径都是<code>/</code>，这里就需要我们进行重定向的设置，将<code>/</code>重定向到<code>/home</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    path: &apos;/&apos;,</div><div class="line">    redirect: &apos;/home&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="history模式"><a href="#history模式" class="headerlink" title="history模式"></a>history模式</h4><p>vue-router默认使用hash模式来模拟一个完整的URL，但是这个并不怎么好看… 我们可以通过设置<code>history</code>模式，使得URL看起来跟正常的一模一样。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const router = new VueRouter(&#123;</div><div class="line">    mode: &apos;history&apos;,</div><div class="line">    routes: [...]</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是这个需要后端同学进行相应的设置。因为我这个只是写的前端demo，后端同学一直在忙别的接口，所以这个地方我并没有过多的尝试。<br>贴个后端设置的链接<a href="http://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="external">vue-router History 模式</a></p>
<h4 id="路由效果"><a href="#路由效果" class="headerlink" title="路由效果"></a>路由效果</h4><p>通过在<code>&lt;router-view&gt;&lt;/router-view&gt;</code>的外面</p>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>如果项目比较大的话，可以新建一个跟<code>main.js</code>平级的<code>router.js</code>来配置路由信息，然后在<code>main.js</code>中引用就好了。如果项目路由不算太多的话，还是直接在<code>main.js</code>中写就好了。</p>
<h2 id="vue-resource"><a href="#vue-resource" class="headerlink" title="vue-resource"></a>vue-resource</h2><p>这个跟angular-resource使用方法基本一致，这里就不在说了。贴个git地址：<a href="https://github.com/pagekit/vue-resource" target="_blank" rel="external">vue-resource</a></p>
<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/ZhangShuangV/vue-boss/tree/master" target="_blank" rel="external">ZhangShuangV/vue-boss</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于angularjs与materialDesign的管理后台]]></title>
      <url>http://zhangshuang.top/%E5%9F%BA%E4%BA%8Eangularjs%E4%B8%8EmaterialDesign%E7%9A%84%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0/</url>
      <content type="html"><![CDATA[<p>最近换了个公司，乱七八糟的事儿比较多，更新耽误了些…<br>之前还看过一段时间的Vuejs，想着新公司如果做项目的话，用Vuejs去做。然而新公司的技术架构pc端更倾向于Angularjs，而且有专门的前端架构，架子什么的都搭的差不多了，所以来到新公司的第一个项目就用Angularjs做的。<br><a id="more"></a><br>通过这个项目，我对eslint、gitignore、proxy也算有了接触。毕竟以前做项目的时候也没关注过这些。这个项目是用gulp跟webpack配合使用的。也是直接用的旧有的架子，没做什么改动。<br>现在就说一下用Angularjs做的这个项目吧。</p>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><ul>
<li>app: 源代码<ul>
<li>views: 一个页面一个文件夹<ul>
<li>*.ctrl Controller</li>
<li>*.html Controller对应的页面</li>
<li>*.scss Controller对应页面的样式表</li>
</ul>
</li>
<li>services: 服务，一个页面可能有多个服务，与页面一一对应</li>
<li>filters: 过滤器</li>
<li>app.js: 项目入口文件</li>
<li>index.html: index</li>
</ul>
</li>
<li>dest: 编译后代码存放的位置，源码中不存在</li>
<li>.eslintrc.json: 语法检查</li>
<li>.gitignore: git忽略目录</li>
<li>.babelrc: babel编译配置</li>
<li>… 其他配置</li>
</ul>
<h2 id="入口文件-app-js"><a href="#入口文件-app-js" class="headerlink" title="入口文件 app.js"></a>入口文件 app.js</h2><p>这个项目使用了angular-resource、angular-material等框架，因为Angularjs是依赖注入的，所以所有依赖的框架、插件甚至服务过滤器等等都需要import进来，并且注入到angular程序中。</p>
<h4 id="Dependencies-项目依赖"><a href="#Dependencies-项目依赖" class="headerlink" title="Dependencies 项目依赖"></a>Dependencies 项目依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import angular from &apos;angular&apos;;</div><div class="line">import &apos;angular-material&apos;;</div><div class="line">import &apos;angular-resource&apos;;</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="View-项目页面，包括其中的Controller及template等"><a href="#View-项目页面，包括其中的Controller及template等" class="headerlink" title="View 项目页面，包括其中的Controller及template等"></a>View 项目页面，包括其中的Controller及template等</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import &#123; Template, Controller &#125; from &apos;./views/page1/page1.ctrl&apos;;</div><div class="line">...</div></pre></td></tr></table></figure>
<h4 id="Service-服务"><a href="#Service-服务" class="headerlink" title="Service 服务"></a>Service 服务</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import IndexMenuResource from &apos;./services/index-menu.resource&apos;</div></pre></td></tr></table></figure>
<h4 id="主程序，所有注入的内容都会在这里体现。"><a href="#主程序，所有注入的内容都会在这里体现。" class="headerlink" title="主程序，所有注入的内容都会在这里体现。"></a>主程序，所有注入的内容都会在这里体现。</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">angular.module(&apos;app&apos;, [</div><div class="line">    &apos;ngResource&apos;, &apos;ngRoute&apos;, &apos;ngMaterial&apos; ...</div><div class="line">])</div><div class="line">.controller(&apos;controller&apos;, Controller)</div><div class="line">.service(&apos;IndexMenuResource&apos;, IndexMenuResource)</div><div class="line">.config([&apos;$routeProvider&apos;, function($routeProvider) &#123;</div><div class="line">    $routeProvider.when(&apos;/&apos;, &#123;</div><div class="line">        template: Template,</div><div class="line">        controller: Controller,</div><div class="line">        controllerAs: &apos;ctrl&apos;</div><div class="line">        &#125;) ...</div><div class="line">    &#125;]);</div></pre></td></tr></table></figure>
<p>在这里，我每一个只写了一个，需要说明一点，使用<code>controllerAs</code>，在其他页面的对应的controller中，就可以不用<code>$scope</code>，转而使用<code>this</code>就可以了。然后需要在controller对应的template中，每一个变量前面都加上controllerAs的内容，也就是上文中的<code>ctrl</code>。<br>这个地方也可以将路由模块抽离出来，但是，看着这个文件也不大，就放在这里吧，维护起来也还算好维护。</p>
<h2 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h2><p>登录模块是最后加的，原型图中也没有这个，但是感觉作为一个后台管理系统，如果没有这个模块，岂不是所有人知道网址就能随意修改内容了么…于是跟后端同事商量了一下，就把这个做上了。因为时间比较紧，项目经理就直接说，暂不需要权限管理，注册之类的，直接把这个东西在后台写死就好。但是后端同学还是为user单独建了张表，把权限也留出口来，以后如果有需要直接加上就好了。  </p>
<p>在这里我就说一下前台是如何实现的：<br>在index.html中，写了一个跟页面平级的div，用于放置登录模块。这里用到了<code>ng-if</code>这个来控制是否显示登录模块。在登录成功后，我会将用户信息用session存到浏览器缓存中，然后将控制登录模块是否显示的字段置为false，然后，在跟controller加载的时候就去session中检查用户信息。这样就可以实现登录成功后，无论怎样刷新，都不会再显示这个页面。</p>
<p>我是用的es6语法写的这个项目，所以在这里也放一下es6写的controller：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export class RootController &#123;</div><div class="line">    constructor(IndexMenuResource, User, $mdDialog) &#123;</div><div class="line">        this.menuRes = IndexMenuResource;</div><div class="line">        this.user = User;</div><div class="line">        this.$mdDialog = $mdDialog;</div><div class="line"></div><div class="line">        this.isUserLogin = false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在constructor构造函数中，将这个controller需要的资源注入进来。这个<code>isUserLogin</code>如果按照之前的写法，需要注入<code>$scope</code>，并将<code>this</code>替换为<code>$scope</code>。但是之前在配置路由的时候提到过，使用了<code>controllerAs</code>这个配置，所以这里就不需要使用<code>$scope</code>。再说一下template中是如何配合使用的:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div ng-if=&quot;root.isUserLogin&quot;&gt;</div><div class="line"></div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>这个<code>root</code>就是之前配置的controllerAs，其他页面以此类推。</p>
<h2 id="导航模块"><a href="#导航模块" class="headerlink" title="导航模块"></a>导航模块</h2><p>回想刚开始做前端的时候，恨不得所有的东西都在html中写死，还美其名曰加快加载进度。但是现在看来，像导航这种东西，还是配置成数据，然后通过各个框架的循环<code>ng-repeat或v-for</code>等这种东西使用起来，才算是优雅（我认为的…）。这样看起来页面不会有那么多重复的东西，显得也比较简洁。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li ng-repeat=&quot;item in root.menus&quot; ng-click=&quot;root.activeMenu($index)&quot; ng-class=&quot;item.active? &apos;zs-toolbar-active&apos; : &apos;&apos;&quot;&gt;</div><div class="line">        &lt;md-button href=&#123;&#123;item.url&#125;&#125; class=&quot;md-icon-button&quot;&gt;</div><div class="line">            &lt;md-icon class=&quot;fl&quot;&gt;&#123;&#123;item.icon&#125;&#125;&lt;/md-icon&gt;</div><div class="line">            &lt;span class=&quot;fl&quot;&gt;&#123;&#123;item.cnt&#125;&#125;&lt;/span&gt;</div><div class="line">        &lt;/md-button&gt;</div><div class="line">    &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>Angularjs的服务具体是什么我就不说了，这里我只是说一下es6是怎么写的。像这个导航模块的服务就相对简单：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">export default function IndexMenuResource() &#123;</div><div class="line">    return [</div><div class="line">        &#123;cnt: &apos;管理1&apos;, icon: &apos;&apos;, url: &apos;#/manager1&apos;, active: false&#125;,</div><div class="line">        ...</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="服务、请求"><a href="#服务、请求" class="headerlink" title="服务、请求"></a>服务、请求</h2><p>上面的导航模块，服务只有这一个功能，所以只是用了一个function，然后export出去就可以了。如果服务功能多一点的话，就需要使用es6的class，同样，需要在constructor中引入依赖。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 单条活动资源。</div><div class="line"> */</div><div class="line">export default class ActivityItemResourceService&#123;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 引入$resource模块</div><div class="line">   * @param $resource</div><div class="line">   */</div><div class="line">  constructor($resource) &#123;</div><div class="line">    this.$resource = $resource;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  /**</div><div class="line">   * 编辑/新建活动</div><div class="line">   * @return &#123; 单条活动资源 &#125;</div><div class="line">   */</div><div class="line">  resActivityItem() &#123;</div><div class="line">    return this.$resource(&apos;cardactivity/activitydetail&apos;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /**</div><div class="line">   * 保存活动</div><div class="line">   * @returns &#123; 更新服务器中的活动资源 &#125;</div><div class="line">   */</div><div class="line">  saveActivityItem() &#123;</div><div class="line">    return this.$resource(&apos;cardactivity/savecardactivity&apos;, &#123;&#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码中可以看出，项目的前后端交互部分是用的<code>$resource</code>，接口是用的restful风格的。<br>最开始我一直想在服务中返回的就是请求回来的资源，但是通过几次尝试，发现非常的不好用。无论是使用<code>$q</code>还是在服务中本地维护一个对象，将请求回来的数据放进去，发现都不好用。最终，在服务中体现的就是上面的样子：实际上是每个资源的地址。在controller中调用时，写上调用这个资源需要的方法。然后在callback中赋值给本地维护的对象。</p>
<h2 id="material-design"><a href="#material-design" class="headerlink" title="material design"></a>material design</h2><p>最初要求项目开发周期较短，并且这个项目只有非常简陋的原型图，所以前端老大说使用angular-material-design来作为UI框架。之前也没接触过，然后就上官网去看demo，需要什么样的样式，就去官网上找对应的demo，然后就大体知道了些。</p>
<h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>这个UI框架跟bootstrap还是有相似之处的，比如说那个布局，确实非常好用。如果想让内容上下分布的话，就用<code>layout=&quot;column&quot;</code>；如果想让内容左右分布的话，就用<code>layout=&quot;row&quot;</code>。内容的大小就可以用<code>flex</code>属性来设置。<br><code>flex</code>属性的最大值为100，设置的最小步长为5，也就是可以设置为10、设置为15可以，但是设置为13就不行。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div layout=&quot;row&quot;&gt;</div><div class="line">    &lt;div flex=&quot;10&quot;&gt;&lt;/div&gt;</div><div class="line">    &lt;div flex=&quot;90&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h4 id="Form表单"><a href="#Form表单" class="headerlink" title="Form表单"></a>Form表单</h4><p>materialDesign中的input都是没有边框的，并且它的input的label是位于input输入框内的，不是左右或上下分离的，这在有很多input的form表单中就显得略微有些怪异。这个就算是加上边框，看起来也略微有点别扭，不过也没办法…既然当初是为了节省时间成本选用的这个框架，如果还是要自定义那么多样式的话，也没必要用UI框架了。<br>如果使用validate功能的话，需要引入<code>angular-messages</code>，但是在引入这个插件的时候，发现报错了，进入源码把带有<code>angularVersion</code>的那一行删掉就好了。这个地方我也不知道是怎么回事，尝试换过angularjs的版本及angular-messages的版本，但是都没有解决，只能删掉这行了。</p>
<h4 id="card"><a href="#card" class="headerlink" title="card"></a>card</h4><p>虽然看官网的demo，card基本是作为类似于微信分享那样，带有图片之类的。但是因为样式设计原因，我更喜欢把他作为一个个区块去使用，带有box-shadow的样式看起来也不错。</p>
<h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><p>这个富文本模块最初的需求中有这个，但是除了管理后台以外，对应的用户界面也是由我开发，找了半天也没找到富文本到底是在哪里使用。后来跟产品沟通了一下，用多行文本<code>textarea</code>就满足需求了。<br>但是自己也尝试了一下，从网上找了个CKEditor的插件，自己写了个demo可以使用。但是用到我的这个项目中就出现问题，写了指令之后也一直报错，找了半天原因也没找到，就暂时放弃了，等再有这个需求的时候再研究吧。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个项目还是让我有很大收获的，除了eslint这种东西，本地开发需要的跨域问题也通过proxy得以解决。也对Angularjs以及angular-material-design有了一定的了解。当然还有开动脑筋把简陋的原型图变成web网站的间接的审美锻炼……</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[前端构建工具的简易实现]]></title>
      <url>http://zhangshuang.top/%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%E7%9A%84%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>虽然说之前用过gulp、webpack这种前端构建工具，但是自己也只是单纯的使用，从来没想过这些东西到底是怎样实现的。最近看了一节公开课，觉得很受启发，现在就说一下我的这个前端构建工具是如何实现的。</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p><code>zst dev</code> 实现保存代码自动刷新的功能。</p>
<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><p><code>zst dist</code> 这个实现的功能较多：  </p>
<ol>
<li>自动生成dist目录</li>
<li>合并压缩js、css添加时间戳输出到dist目录</li>
<li>将favicon.ico文件复制到dist目录</li>
<li>处理index.html文件，删除注释</li>
<li>如果开发的是移动端页面，还会在index.html中插入移动端meta及处理rem的代码</li>
</ol>
<a id="more"></a>
<h4 id="用到的模块："><a href="#用到的模块：" class="headerlink" title="用到的模块："></a>用到的模块：</h4><p>express、watch、command、fs、path、uglifyjs、uglifycss、cheerio、open、package、http、socket.io  </p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h4 id="config"><a href="#config" class="headerlink" title="config"></a>config</h4><p>我们需要一个config对象来作为项目的配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const config = &#123;</div><div class="line">    server: &#123;</div><div class="line">        ip: &quot;http://localhost&quot;,</div><div class="line">        port: 3000</div><div class="line">    &#125;,</div><div class="line">    input: &quot;./src&quot;,</div><div class="line">    output: &quot;./dist&quot;,</div><div class="line">    info: &quot;INFO  &quot;,</div><div class="line">    isPhone: true, //是否是手机</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>server</code>字段设置的是服务的ip跟端口，<code>input</code>字段是输入路径，<code>output</code>字段是输出路径，<code>info</code>字段是打印log的日志头，<code>isPhone</code>字段是是否是移动端。</p>
<h4 id="开发环境-1"><a href="#开发环境-1" class="headerlink" title="开发环境"></a>开发环境</h4><ol>
<li>首先，我们需要创建一个http服务在3000端口，这里我们使用express这个框架来实现。  <figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var app = require(&apos;express&apos;);</div><div class="line">var server = require(&apos;http&apos;).createServer(app);</div><div class="line">server.listen(config.server.port, function (req, res) &#123;</div><div class="line">    log(&apos;server start at &apos;+config.server.ip+&quot;:&quot;+config.server.port);</div><div class="line">&#125;);</div><div class="line">app.get(&apos;/&apos;, function (req, res) &#123;</div><div class="line">    res.send(getHtml(config.isPhone,config.input));</div><div class="line">&#125;);</div><div class="line"></div><div class="line">function getHtml(isPhone,path) &#123;</div><div class="line">    var path = path || &apos;./src&apos;;</div><div class="line">    var devHtml = fs.readFileSync(path +&apos;/index.html&apos;, &apos;utf-8&apos;) + fs.readFileSync(&apos;./socket.xml&apos;);</div><div class="line">    if(isPhone) return fs.readFileSync(&apos;./isphone.xml&apos;) + devHtml;</div><div class="line">    else return devHtml;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在这段代码中，server.listen是在config.server.port端口开启一个服务器，cb会在服务开启后执行。<br>app.get()是express的路由，当客户端访问到<code>/</code>时，返回给客户端什么内容。<br>getHtml方法最终返回的是加上处理自动刷新代码的index.html。<br>如果要开启服务器后自动打开客户端，可以使用open插件:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var open = require(&apos;open&apos;); //自动打开浏览器</div><div class="line">server.listen(config.server.port, function (req, res) &#123;</div><div class="line">    log(&apos;server start at &apos;+config.server.ip+&quot;:&quot;+config.server.port);</div><div class="line">    open(config.server.ip+&quot;:&quot;+config.server.port);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<ol>
<li>使用socket.io及watch<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var io = require(&apos;socket.io&apos;).listen(server);</div><div class="line">io.sockets.on(&apos;connection&apos;, function (socket) &#123;</div><div class="line">    watch.watchTree(config.input, function (f, curr, prev) &#123;</div><div class="line">        if (typeof f == &quot;object&quot; &amp;&amp; prev === null &amp;&amp; curr === null) &#123;</div><div class="line">            // Finished walking the tree</div><div class="line">        &#125; else &#123; // f was changed</div><div class="line">            socket.emit(&apos;file-change&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    log(&apos;client connected&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>socket.io是websocket长链接通信的封装，之前在egret游戏中使用了websocket通信，但是没有使用socket.io。<br>这个就是当socket连接后，执行的操作，也就是使用watch插件进行文件的监控。使用方式都有注释，也可以从github上进行搜索。最后一个else中，<code>socket.emit</code>是自定义的事件名，文件改变。<br>在js中写了这个还需要在html中接收<code>file-change</code>事件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* socket.xml */</div><div class="line">&lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    var socket = io.connect(&apos;ws://localhost:3000&apos;);</div><div class="line">    socket.on(&apos;file-change&apos;, function (data) &#123;</div><div class="line">        location.reload();</div><div class="line">    &#125;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>上面这段代码是单独放到一个xml文件中的，在上面的<code>getHtml</code>方法中，如果是开发模式的话，会在index.html中自动添加上这段代码。<br>如果要在手机中看的话，需要将<code>socket</code>变量改成本机的ip，mac电脑使用<code>ifconfig</code>查看，windows电脑使用<code>ipconfig</code>查看。<br>这里<code>socket.on</code>监听到<code>file-change</code>事件之后就刷新页面。</p>
<h4 id="生产环境-1"><a href="#生产环境-1" class="headerlink" title="生产环境"></a>生产环境</h4><p>生产环境的功能较多</p>
<ol>
<li>处理css<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var uglifyCss = require(&apos;uglifycss&apos;); //合并压缩css</div><div class="line">var fs = require(&apos;fs&apos;); //nodejs文件处理模块</div><div class="line"></div><div class="line">function handleCss() &#123; //处理css</div><div class="line">    let uglifiedCss = uglifyCss.processFiles(getCssArr(), &#123; maxLineLen: 500, expandVars: true&#125;); // 合并压缩css</div><div class="line">    var cssName = &quot;./bundle.&quot; + new Date().getTime() + &quot;.css&quot;; //添加时间戳</div><div class="line">    fs.writeFileSync(config.output+&apos;/&apos;+cssName.slice(1), uglifiedCss); //将合并的css文件写入bundle.css</div><div class="line">    log(&apos;Create bundle.css succeed&apos;);</div><div class="line">    $(&apos;head&apos;).append(&apos;&lt;link href=&quot;&apos;+cssName+&apos;&quot; rel=&quot;stylesheet&quot;/&gt;&apos;); //在html中添加打包好的css、js文件</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getCssArr() &#123; //获取css的href属性列表</div><div class="line">    let cssArr = [];</div><div class="line">    let link = $(&apos;link&apos;);</div><div class="line">    let ico = $(&apos;link&apos;)[$(&apos;link&apos;).length - 1]; //找到favicon.ico的link标签</div><div class="line">    // let ico = $(&apos;link&apos;).pop();</div><div class="line">    ico.attribs.href = &apos;./favicon.ico&apos;;</div><div class="line">    for(let i = 0, len = link.length - 1; i &lt; len; i++) &#123; //length-1是因为有favicon</div><div class="line">        cssArr.push(config.input+link[i].attribs.href.slice(1));</div><div class="line">    &#125;</div><div class="line">    link.remove(); //删除原来的link标签</div><div class="line">    $(&apos;head&apos;).append(ico); //添加ico标签</div><div class="line">    return cssArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里用到了nodejs的filesystem跟uglifiycss插件。<br>这里需要先引入uglifycss，其中第一个参数是一个数组对象，存放的是所有要压缩合并的css文件。这个数组可以通过<code>getCssArr</code>方法得到。<br>nodejs的fs系统有个<code>writeFileSync</code>接受输出路径跟输出内容，会在指定路径生成文件，这里就配合<code>new Date().getTime()</code>输出了带有时间戳的css文件。<br>在<code>getCssArr</code>方法中，因为我在index.html文件中写上了favicon.ico，所以这里需要将最后一个<code>link</code>标签也就是存放favicon.ico的标签单独处理。</p>
<ol>
<li><p>处理js<br>处理js跟处理css几乎是一模一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function handleJs() &#123; //处理js</div><div class="line">    let uglifiedJs = uglifyJS.minify(getJsArr(), &#123; //合并压缩js</div><div class="line">        compress: &#123;</div><div class="line">            dead_code: true,</div><div class="line">            global_defs: &#123;</div><div class="line">                DEBUG: false</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    var jsName = &quot;./bundle.&quot; + new Date().getTime() + &quot;.js&quot;;</div><div class="line">    fs.writeFileSync(config.output+&apos;/&apos;+jsName.slice(1), uglifiedJs.code);</div><div class="line">    log(&apos;Create bundle.js succeed&apos;);</div><div class="line">    $(&apos;body&apos;).append(&apos;&lt;script src=&quot;&apos;+jsName+&apos;&quot; /&gt;&lt;/script&gt;&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getJsArr() &#123; //获取js的src属性列表</div><div class="line">    let scriptArr = [];</div><div class="line">    let script = $(&apos;script&apos;);</div><div class="line">    for(let i = 0, len = script.length - 2; i &lt; len; i++) &#123; //length-2是因为会在html最后增添socket.xml中的script标签</div><div class="line">        if(script[i].attribs.src) scriptArr.push(config.input+&quot;/&quot; + script[i].attribs.src); //如果有这个属性就添加到scriptArr中，之后会进行合并压缩</div><div class="line">    &#125;</div><div class="line">    script.remove(); //删除原来的script标签</div><div class="line">    return scriptArr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>复制icon</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function handleIcon() &#123; //处理favicon.ico</div><div class="line">    let inputPath = config.input + &apos;/img/favicon.ico&apos;;</div><div class="line">    let outputPath = config.output + &apos;/favicon.ico&apos;;</div><div class="line">    let readStream = fs.createReadStream(inputPath);</div><div class="line">    let writeStream = fs.createWriteStream(outputPath);</div><div class="line">    readStream.pipe(writeStream);</div><div class="line">    log(&apos;Create favicon.ico succeed&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这里用到的fs系统的读写文件流。</p>
<ol>
<li>处理目录<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function handleDir() &#123; //删除原有目录，生成新目录</div><div class="line">    let dirpath = config.output;</div><div class="line">    if(fs.existsSync(dirpath)) &#123; //监测目录是否存在</div><div class="line">        delDir(dirpath); //存在就递归删除目录</div><div class="line">        end = new Date().getMilliseconds();</div><div class="line">        log(&apos;Delete &apos;+dirpath.slice(2)+&apos; dir succeed&apos;);</div><div class="line">        fs.mkdirSync(dirpath); //生成目录</div><div class="line">        end = new Date().getMilliseconds();</div><div class="line">        log(&apos;Create &apos;+dirpath.slice(2) + &apos; dir succeed&apos;);</div><div class="line">    &#125;else &#123;</div><div class="line">        fs.mkdirSync(dirpath); //生成目录</div><div class="line">        end = new Date().getMilliseconds();</div><div class="line">        log(&apos;Create &apos;+dirpath.slice(2) + &apos; dir succeed&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function delDir(path) &#123; //递归删除生产环境输出目录</div><div class="line">    var files = [];</div><div class="line">    files = fs.readdirSync(path);</div><div class="line">    files.forEach(function (file, index) &#123;</div><div class="line">        var curPath = path + &apos;/&apos; + file;</div><div class="line">        if(fs.statSync(curPath).isDirectory()) &#123;</div><div class="line">            delDir(curPath);</div><div class="line">        &#125;else &#123;</div><div class="line">            fs.unlinkSync(curPath);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    fs.rmdirSync(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个目录如果是不删除的话，每次使用<code>zst dist</code>命令都会重新生成带事件戳的css文件、js文件，会导致文件过的问题。所以最好是在生成文件前先删除目录，再添加目录，然后在将处理好的css、js文件等放入目录。<br>因为使用nodejs删除文件夹的话，如果文件夹内容不为空，没有办法删除，所以这里需要使用递归来删除文件夹。</p>
<ol>
<li>处理index.html<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function handleHtml() &#123; //处理html</div><div class="line">    let regex = /&lt;!--[\s\S]*?--&gt;/g; //删除html中的注释</div><div class="line">    let html = $.html().replace(regex, &apos;&apos;);</div><div class="line"></div><div class="line">    regex = /\s&#123;10,&#125;/g; //删除多余的空行</div><div class="line">    html = html.replace(regex, &apos;&apos;);</div><div class="line"></div><div class="line">    $(&apos;html&apos;).html(html); //重新赋值html文件</div><div class="line">    log(&apos;Create index.html succeed&apos;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>通过使用正则来删除index.html中的注释跟多余的空行。</p>
<h4 id="cli"><a href="#cli" class="headerlink" title="cli"></a>cli</h4><p>我们肯定是希望插件是一个命令行插件，这样就可以通过执行上面说的两个命令<code>zst dev</code>跟<code>zst dist</code>在进行开发环境跟生产环境的不同处理。<br>这里我们需要使用nodejs不内置的command模块。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#! /usr/bin/env node</div><div class="line">var command = require(&apos;commander&apos;); //nodejs命令模块</div><div class="line"></div><div class="line">command.version(package.version); //版本号</div><div class="line">command.command(&apos;dev&apos;).action(function () &#123; develop(); &#125;);</div><div class="line">command.command(&apos;dist&apos;).action(function () &#123; bundle(); &#125;);</div><div class="line">command.parse(process.argv); //开始解析用户输入的命令，这个不能跟上面的命令放到同一行</div></pre></td></tr></table></figure></p>
<p>第一句的<code>#! /usr/bin/env node</code>是使用nodejs来执行这段脚本。<br>我们需要在package.json中添加一个字段：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;bin&quot;: &#123;</div><div class="line">  &quot;zst&quot;: &quot;./zst.config.js&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果是在本地使用的话，运行<code>npm link</code>就可以将其打包为命令行工具。<br>如果要发布到npm上的话：<br>首先：在命令行中输入<code>npm login</code>登录自己的npm账户(如果没有请到<a href="https://www.npmjs.com自行注册。" target="_blank" rel="external">https://www.npmjs.com自行注册。</a>)<br>然后：输入<code>npm publish</code>就可以将自己写的插件作为一个npm包上传到npm服务器中。<code>npm install zst -g</code>下载下来就可以了。  </p>
<p>到了这一步，我们通过上面的命令下载下来可以发现，这个没法生成项目目录，而是存在在本机的node环境中可以使用。所以我们还需要给这个构建工具加一个壳子。</p>
<h4 id="zst-web"><a href="#zst-web" class="headerlink" title="zst-web"></a>zst-web</h4><p>我们需要像<code>vue-cli</code>那样，运行命令直接生成项目模板，这就需要我们在这个zst外面加上一个壳子。<br>使用npm init 新建一个项目，这个需要依赖commander、bluebird还有fs-extra模块。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* generateStructure.js */</div><div class="line">var Promise = require(&quot;bluebird&quot;),</div><div class="line">    fs = Promise.promisifyAll(require(&apos;fs-extra&apos;));</div><div class="line"></div><div class="line">var root = __dirname.replace(/zst-web\/lib/,&apos;zst-web/&apos;);</div><div class="line"></div><div class="line">function generateStructure(project)&#123;</div><div class="line">    return fs.copySync(root + &apos;structure&apos;, project,&#123;clobber: true&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">module.exports = generateStructure;</div></pre></td></tr></table></figure></p>
<p>通过bluebird跟fs-extra我们就可以实现将一个目录复制到另一个目录。这里的<code>root</code>是为了防止找不到复制源头的bug。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* zst.js */</div><div class="line">var command = require(&apos;commander&apos;);</div><div class="line">var gs = require(&apos;../lib/generaterStructure&apos;);</div><div class="line"></div><div class="line">command</div><div class="line">    .version(require(&apos;../package.json&apos;).version)</div><div class="line">    .usage(&apos;[options] [project name]&apos;)</div><div class="line">    .parse(process.argv);</div><div class="line"></div><div class="line">var dir = command.args[0];</div><div class="line">if(!dir) command.help();</div><div class="line"></div><div class="line">gs(dir);</div></pre></td></tr></table></figure>
<p>这个地方的<code>dir</code>就是通过commander模块来截取commander管道中传入的参数，就类似于我们经常使用的<code>gulp server</code>后面的<code>server</code>。这样我们就能实现输入命令<code>zst-web [project name]</code>创建之前的zst中的所有内容。</p>
<h4 id="终"><a href="#终" class="headerlink" title="终"></a>终</h4><p>这样，这个前端构建工具就实现了，我们可以通过：<br><code>npm install -g zst-web zst</code>来安装zst这个构建工具跟zst-web这个命令行构建工具。<br><code>zst-web [project name]</code>生成项目。</p>
<p>完整代码在我的<a href="https://github.com/ZhangShuangV/zst-web" target="_blank" rel="external">github</a>中有，欢迎大家提意见。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[shell基本命令]]></title>
      <url>http://zhangshuang.top/shell%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<p>因为公司里有个项目改完ui层后，需要运行很多命令才能讲ui层打包并重启项目，那些命令一个一个的去复制感觉有些麻烦，所以想弄个shell脚本来解决这个问题。</p>
<h4 id="1-Hello-World"><a href="#1-Hello-World" class="headerlink" title="1. Hello World!"></a>1. Hello World!</h4><h5 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash  // #!是一个约定，告诉系统这个脚本需要何种解释器来执行  </div><div class="line">echo &quot;Hello World!&quot; //echo命令用于向窗口输出文本。</div></pre></td></tr></table></figure>
<h5 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h5><p>将上面的代码保存为test.sh，并cd到相应目录:<br><code>chmod +x ./test.sh</code>，使脚本具有执行权限；<br><code>./test.sh</code>，执行脚本。</p>
<h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>必须写成<code>./test.sh</code>，否则系统会从<code>PATH</code>中寻找；如果使用<code>/bin/sh</code>作为解释器，第一行可以省略。<br><a id="more"></a></p>
<h4 id="2-read命令"><a href="#2-read命令" class="headerlink" title="2. read命令"></a>2. read命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">echo &quot;Hello, what is your name?&quot;</div><div class="line">read PERSON</div><div class="line">echo &quot;Hello, $PERSON!&quot; #此处必须是双引号，单引号不会使用变量的值</div></pre></td></tr></table></figure>
<p>通过<code>read</code>命令从stdin获取输入并赋值给<code>PERSON</code>变量，最后在stdout上输出。</p>
<h4 id="3-定义变量"><a href="#3-定义变量" class="headerlink" title="3. 定义变量"></a>3. 定义变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">myUrl=&quot;http://www.zhangshuang.top&quot;</div><div class="line">myName=&quot;张爽&quot;</div><div class="line">myAge = &quot;26&quot; #识别不出来，不能有空格</div><div class="line"></div><div class="line">echo &quot;My name is $&#123;myName&#125;&quot;</div><div class="line">echo &quot;My blog site is $myUrl&quot;</div><div class="line">echo &quot;I&apos;m $&#123;myAge&#125; years old&quot; #这句话会报错</div></pre></td></tr></table></figure>
<p>变量名在使用的时候，前面必须有<code>$</code>符号，可选添加{}表示变量边界。从新定义变量跟第一次定义变量写法一样。</p>
<h4 id="4-readonly-只读变量"><a href="#4-readonly-只读变量" class="headerlink" title="4. readonly 只读变量"></a>4. readonly 只读变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">myUrl=&quot;http://www.zhangshuang.top&quot;</div><div class="line">readonly myUrl</div><div class="line">myUrl=&quot;http://zhangshuang.top&quot; #此句运行时会报错，提示该变量为只读变量</div></pre></td></tr></table></figure>
<h4 id="5-unset-删除变量"><a href="#5-unset-删除变量" class="headerlink" title="5. unset 删除变量"></a>5. unset 删除变量</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">myUrl=&quot;http://www.zhangshuang.top&quot;</div><div class="line">unset myUrl</div><div class="line">echo &quot;$&#123;myUrl&#125;&quot; #此句运行时会报错，提示找不到变量</div><div class="line"></div><div class="line">myUrl=&quot;http://www.zhangshuang.top&quot;</div><div class="line">readonly myUrl</div><div class="line">unset myUrl #报错，只读变量无法删除</div><div class="line">echo &quot;$&#123;myUrl&#125;&quot;</div></pre></td></tr></table></figure>
<h4 id="6-获取字符串长度"><a href="#6-获取字符串长度" class="headerlink" title="6. 获取字符串长度"></a>6. 获取字符串长度</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">url=&quot;http://www.zhangshuang.top&quot;</div><div class="line">echo &quot;url length is $#url&quot; #$&#123;#url&#125;获取字符串length</div></pre></td></tr></table></figure>
<h4 id="7-提取字符串"><a href="#7-提取字符串" class="headerlink" title="7. 提取字符串"></a>7. 提取字符串</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">url=&quot;http://www.zhangshuang.top&quot;</div><div class="line">echo &quot;$&#123;url:1:4&#125;&quot; #从第二个字符到第五个字符(索引从0开始)</div></pre></td></tr></table></figure>
<h4 id="8-if…else"><a href="#8-if…else" class="headerlink" title="8. if…else"></a>8. if…else</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">if [ $PERSON == &quot;shuang&quot; ] #注意必须有空格</div><div class="line">then</div><div class="line">    echo &quot;My name is $&#123;myName&#125;&quot; #缩进可以没有，有的话可读性高一些</div><div class="line">    echo &quot;My blog site is $&#123;myUrl&#125;&quot;</div><div class="line">    echo &quot;I&apos;m $&#123;myAge&#125; years old&quot;</div><div class="line">fi #表示结束</div></pre></td></tr></table></figure>
<h4 id="9-完成一个命令后再执行另一个命令"><a href="#9-完成一个命令后再执行另一个命令" class="headerlink" title="9. 完成一个命令后再执行另一个命令"></a>9. 完成一个命令后再执行另一个命令</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">starttime=$(date +%s) #获取开始执行脚本的时间毫秒数</div><div class="line"></div><div class="line">cd /usr/Hyg #进入项目路径</div><div class="line">output=`docker rm -f hygui` #通过output使得该命令执行完后再执行下个命令</div><div class="line">output=`docker rmi hyg-ui`</div><div class="line">output=`mvn clean package -pl UI docker:build`</div><div class="line">output=`docker run -d -h=&quot;hygui&quot; -it -p 8088:80 --link`</div></pre></td></tr></table></figure>
<h4 id="10-计算时间差"><a href="#10-计算时间差" class="headerlink" title="10. 计算时间差"></a>10. 计算时间差</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">starttime=$(date +%s) #获取开始执行脚本的时间毫秒数</div><div class="line"></div><div class="line"># date +%Y-%m-%d获取当前日期</div><div class="line"># 脚本内容</div><div class="line"># 脚本内容</div><div class="line"></div><div class="line">endtime=$(date +%s) #获取开始执行脚本的时间毫秒数</div><div class="line">interval=`expr $&#123;endtime&#125; - $&#123;starttime&#125;` #计算项目运行时间</div><div class="line"></div><div class="line">echo &quot;INFO  generated in $&#123;interval&#125; s&quot; #输出时间差</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[vue匹配模板简单实现]]></title>
      <url>http://zhangshuang.top/vue%E5%8C%B9%E9%85%8D%E6%A8%A1%E6%9D%BF%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>之前在学习新框架的时候，只是简单的跟着教程一步一步的敲demo，从来没有想过这个框架是如何实现的，简单的功能我能不能实现。最近打算开始学习Vue，觉得还是尝试一下能不能自己简单的实现其中的某些功能吧。</p>
<p>感觉模板引擎后端同学用的多一些，像jade、FreeMarker等，这个通常是在客户端发出HTTP请求之后，应用层的控制器(Controller)接收，通过应用层的服务器(service)访问数据库，然后封装到模型层(Model)，再跳转到视图层(View)，通过模板引擎生成HTML代码，最后返回给客户端浏览器。<br><a id="more"></a><br>但是Vuejs也是有模板的，他的模板引擎是在客户端浏览器的内存中处理生成的。所以我们用模板的时候，显示出来的是要渲染的数据。</p>
<h3 id="Vue官网的第一个demo"><a href="#Vue官网的第一个demo" class="headerlink" title="Vue官网的第一个demo"></a>Vue官网的第一个demo</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div id=&quot;app&quot;&gt;</div><div class="line">    &#123;&#123; message &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var app = new Vue(&#123;</div><div class="line">    el: &apos;#app&apos;,</div><div class="line">    data: &#123;</div><div class="line">        message: &apos;Hello Vue!&apos;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>看到这个部分，感觉应该可以通过正则来简单的实现一下：<br>html部分不变。</p>
<h5 id="正则部分："><a href="#正则部分：" class="headerlink" title="正则部分："></a>正则部分：</h5><p>首先想到的是匹配两边的大括号，<code>/\{\{\}\}/</code>，注意转译;<br>然后我们需要匹配大括号中间的内容，<code>[\w]+</code>;<br>这里需要注意一个问题，在匹配的内容前后可能会有空格，所以这里内容部分我们需要修改成<code>\s*[\w]+\s*</code>;<br>但是如果需要替换的话，使用正则的分组用法<code>$1</code>会比较轻松的解决这个问题;<br>所以正则的最终版就变成了<code>/(\{\{\s*([\w]+)\s*\}\})/g</code>;</p>
<h5 id="js部分："><a href="#js部分：" class="headerlink" title="js部分："></a>js部分：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function vue(options) &#123;</div><div class="line">    var context = document.querySelector(options.el);</div><div class="line">    var html = context.innerHTML;</div><div class="line">    var regex = /(\&#123;\&#123;\s*([\w]+)\s*\&#125;\&#125;)/g;</div><div class="line">    while(regex.test(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1, options.data[RegExp.$2]);</div><div class="line">    &#125;</div><div class="line">    context.innerHTML = html;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>$1</code>是最先匹配到的<code>{{}}</code><br>包括其内的部分，<code>$2</code>是匹配的要替换的对象。<br>使用方法跟vue的使用方法一样。<br>这样第一个demo我们就简单的实现了。当然相比vue有非常多的缺陷，比如不可以通过<code>app.message</code>来修改数据…</p>
<h3 id="第二个demo，匹配v-bind"><a href="#第二个demo，匹配v-bind" class="headerlink" title="第二个demo，匹配v-bind:"></a>第二个demo，匹配<code>v-bind:</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div id=&quot;app-2&quot;&gt;</div><div class="line">    &lt;span v-bind:title=&quot;message&quot;&gt;</div><div class="line">        Hover your mouse over me for a few seconds</div><div class="line">        to see my dynamically bound title!</div><div class="line">    &lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var app2 = new Vue(&#123;</div><div class="line">    el: &apos;#app-2&apos;,</div><div class="line">    data: &#123;</div><div class="line">        message: &apos;You loaded this page on &apos; + new Date()</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="正则部分"><a href="#正则部分" class="headerlink" title="正则部分"></a>正则部分</h5><p>第二个demo换成了匹配<code>v-bind:</code>，所以正则就变成了<br><code>/(v\-bind:([\w]+)=\&quot;([\w]+)\&quot;)/g</code>;  </p>
<h5 id="js部分"><a href="#js部分" class="headerlink" title="js部分"></a>js部分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Vue(options) &#123;</div><div class="line">    var context = document.querySelector(options.el),</div><div class="line">        html = context.innerHTML,</div><div class="line">        regex = /(v\-bind:([\w]+)=\&quot;([\w]+)\&quot;)/g;</div><div class="line">    while(regex.exec(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1,RegExp.$2+&quot;=&apos;&quot;+options.data[RegExp.$3]+&quot;&apos;&quot;);</div><div class="line">    &#125;</div><div class="line">    context.innerHTML = html;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="第三个demo，匹配v-if"><a href="#第三个demo，匹配v-if" class="headerlink" title="第三个demo，匹配v-if"></a>第三个demo，匹配<code>v-if</code></h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div id=&quot;app-3&quot;&gt;</div><div class="line">    &lt;p v-if=&quot;seen&quot;&gt;Now you see me&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var app3 = new Vue(&#123;</div><div class="line">    el: &apos;#app-3&apos;,</div><div class="line">    data: &#123;</div><div class="line">        seen: true</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h5 id="正则部分-1"><a href="#正则部分-1" class="headerlink" title="正则部分"></a>正则部分</h5><p>替换<code>v-if</code>相对于<code>v-bind:</code>这个还简单一些：<br><code>/(v\-if=\&quot;([\w]+)\&quot;)/g</code>;</p>
<h5 id="js部分-1"><a href="#js部分-1" class="headerlink" title="js部分"></a>js部分</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Vue(options) &#123;</div><div class="line">    var context = document.querySelector(options.el),</div><div class="line">        html = context.innerHTML,</div><div class="line">        regex = /(v\-if=\&quot;([\w]+)\&quot;)/g;</div><div class="line">    while(regex.exec(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1,options.data[RegExp.$2] ? &apos;style=&quot;display:block&quot;&apos; : &apos;style=&quot;display:none&quot;&apos;);</div><div class="line">    &#125;</div><div class="line">    context.innerHTML = html;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来个对比：<br><img src="https://ooo.0o0.ooo/2017/04/11/58ec678a6f5ea.png" alt="v-if"><br>vue的v-if<br><img src="https://ooo.0o0.ooo/2017/04/11/58ec67a2de1aa.png" alt="my-vue-show"><br>自己实现的v-if<br>在显示效果上虽然是一样的，如果<code>v-if</code>中的布尔值为<code>false</code>时，在界面上都不会显示出来。但是，我们打开控制台，查看demo结构我们可以发现，vue实现的<code>v-if</code>，如果布尔值为<code>false</code>时，是直接将这个元素移除DOM树(DOMElement.remove())；而我们自己实现的是将这个元素的<code>display</code>属性设为<code>none</code>。这个效果实际上跟vue的<code>v-show</code>是一样的。</p>
<h3 id="最后将这三个demo合并起来"><a href="#最后将这三个demo合并起来" class="headerlink" title="最后将这三个demo合并起来"></a>最后将这三个demo合并起来</h3><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function Vue(options) &#123;</div><div class="line">    var context = document.querySelector(options.el),</div><div class="line">        html = context.innerHTML,</div><div class="line">        regex = /(\&#123;\&#123;\s*([\w]+)\s*\&#125;\&#125;)/g;</div><div class="line">    while(regex.exec(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1, options.data[RegExp.$2]);</div><div class="line">    &#125;</div><div class="line">    regex = /(v\-bind:([\w]+)=\&quot;([\w]+)\&quot;)/g;</div><div class="line">    while(regex.exec(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1,RegExp.$2+&quot;=&apos;&quot;+options.data[RegExp.$3]+&quot;&apos;&quot;);</div><div class="line">    &#125;</div><div class="line">    regex = /(v\-if=\&quot;([\w]+)\&quot;)/g;</div><div class="line">    while(regex.exec(html)) &#123;</div><div class="line">        html = html.replace(RegExp.$1,options.data[RegExp.$2] ? &apos;style=&quot;display:block&quot;&apos; : &apos;style=&quot;display:none&quot;&apos;);</div><div class="line">    &#125;</div><div class="line">    context.innerHTML = html;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>虽然实现了这几个效果，但是这个跟vue的实现方式是不一样的。比如之后的双向绑定，如果继续通过上面的代码，可能就会出现一些问题，或者实现起来会比较乱。这个还需要对vue更加深入了解以后，再进行尝试吧。</p>
<p>附：<br><a href="https://vuefe.cn/v2/guide/" target="_blank" rel="external">vue官网</a><br><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="external">正则表达式-语法</a><br><a href="http://tool.oschina.net/regex/" target="_blank" rel="external">在线正则表达式测试</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[doTjs详细介绍]]></title>
      <url>http://zhangshuang.top/doTjs%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>doT.js是一个小巧快速的JavaScript模板引擎，他可以帮助我们在html端更好的使用json数据，且无需依赖其他插件就可工作。整个插件只有120行，<code>.min.js</code>文件甚至只有4kb。<br>官网：<a href="http://olado.github.io/doT/index.html" target="_blank" rel="external">http://olado.github.io/doT/index.html</a>  </p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><code>npm install dot</code>  </p>
<h5 id="1-用于nodejs"><a href="#1-用于nodejs" class="headerlink" title="1. 用于nodejs"></a>1. 用于nodejs</h5><p><code>require(&#39;dot&#39;);</code>  </p>
<h5 id="2-浏览器"><a href="#2-浏览器" class="headerlink" title="2. 浏览器"></a>2. 浏览器</h5><p><code>&lt;script type=&quot;text/javascript&quot; src=&quot;./doT.js&quot;&gt;&lt;/script&gt;</code>  </p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>html:<br><code>&lt;div id=&quot;int&quot;&gt;&lt;/div&gt;</code>  </p>
<h5 id="1-赋值"><a href="#1-赋值" class="headerlink" title="1. 赋值"></a>1. 赋值</h5><p>格式：<br>
{{= }}  
</p>
<a id="more"></a>
<p>模板:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script id=&quot;intTmpl&quot; type=&quot;text/template&quot;&gt;</div><div class="line">    &lt;p&gt;My name is &#123;&#123;=it.name&#125;&#125;, I&apos;m &#123;&#123;=it.age&#125;&#125;&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>调用方式:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var data = &#123;name: &apos;John&apos;, age: 26&#125;;</div><div class="line">var intTmpl = doT.template(document.getElementById(&apos;intTmpl&apos;).innerText);</div><div class="line">document.getElementById(&apos;int&apos;).innerHTML = intTmpl(data);</div></pre></td></tr></table></figure>
<p>从上面的代码中我们可以看到，有一个<code>it</code>，这个是代指引用的数据，也就是代码中的<code>data</code>，<code>it.name</code>就是<code>data.name</code>，所以这个在使用方法上实际跟<code>json</code>、<code>对象</code>是一样一样的。<br>在调用方式上，都是3个步骤:  </p>
<ol>
<li>先声明数据源，也就是代码中的<code>data</code>，这个一般情况下是后端同学传回来的。  </li>
<li>找到要将数据填进去的模板。  </li>
<li>找到你要渲染的位置。这个位置就是上面html中的<code>int</code>。</li>
</ol>
<h5 id="2-条件"><a href="#2-条件" class="headerlink" title="2. 条件"></a>2. 条件</h5><p>格式:    </p>

{{? }}
  //if<br>
{{?? }}  
  //else if<br>
{{??}}   
 //else<br><br>模板:<br><br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script id=&quot;intTmpl&quot; type=&quot;text/template&quot;&gt;</div><div class="line">    &#123;&#123;? it.name&#125;&#125;</div><div class="line">    &lt;p&gt;Hello, my name is &#123;&#123;=it.name&#125;&#125;&lt;/p&gt;</div><div class="line">    &#123;&#123;?? it.age&#125;&#125;</div><div class="line">    &lt;p&gt;I&apos;m &#123;&#123;=it.age&#125;&#125;&lt;/p&gt;</div><div class="line">    &#123;&#123;??&#125;&#125;</div><div class="line">    &lt;p&gt;Nobody here!&lt;/p&gt;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>调用方式:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var data = &#123;name: &apos;John&apos;, age: &apos;26&apos;&#125;;</div><div class="line">var intTmpl = doT.template(document.getElementById(&apos;intTmpl&apos;).innerText);</div><div class="line">document.getElementById(&apos;int&apos;).innerHTML = intTmpl(data);</div></pre></td></tr></table></figure>
<p>调用方式都是一样的。</p>
<h5 id="3-转译html"><a href="#3-转译html" class="headerlink" title="3. 转译html"></a>3. 转译html</h5><p>格式:<br>
{{! }}
<br>模板:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script id=&quot;intTmpl&quot; type=&quot;text/template&quot;&gt;</div><div class="line">    &#123;&#123;!it.uri&#125;&#125; &#123;&#123;!it.html&#125;&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>调用方式:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var data = &#123;uri:&quot;http://www.zhangshuang.top&quot;, html:&quot;&lt;span style=&apos;color:red;&apos;&gt;html元素&lt;/span&gt;&quot;&#125;;</div><div class="line">剩下的跟上面一样。</div></pre></td></tr></table></figure>
<p>转译跟赋值的区别:<br>转译是让html标签不使用html引擎渲染，也就是不会解析html构建DOM树，也不渲染树结构、布局、绘制样式等等，而是直接变成字符串渲染出来。<br>赋值的话，如果数据中有html标签，就会解析html构建DOM树，渲染树结构，渲染树布局，绘制渲染树。</p>
<h5 id="4-数组迭代"><a href="#4-数组迭代" class="headerlink" title="4. 数组迭代"></a>4. 数组迭代</h5><p>格式:<br>
{{~ }}
<br>模板:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;&#123;~it.array:value:index&#125;&#125;</div><div class="line">    &lt;p&gt;&#123;&#123;=index+1&#125;&#125;：&#123;&#123;=value&#125;&#125;&lt;/p&gt;</div><div class="line">&#123;&#123;~&#125;&#125;</div></pre></td></tr></table></figure>
<p>调用方式:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var data = &#123;array: [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]&#125;;</div><div class="line">剩下两个步骤跟上面一样。</div></pre></td></tr></table></figure>
<p>其中<code>it.array是找到那个数组</code>，<code>value</code>是数组中的每一个值，<code>index</code>是数组的下标，换成a或b或其他都行。  </p>
<p>上面这些事比较常用的，甚至，只要会使用<code>json</code>都能很好的使用doT.js，也就是每一个都通过赋值的方式去找。还有一些其他的，如果有想了解的也可以去官网了解一下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基础真的很重要]]></title>
      <url>http://zhangshuang.top/%E5%9F%BA%E7%A1%80%E7%9C%9F%E7%9A%84%E5%BE%88%E9%87%8D%E8%A6%81/</url>
      <content type="html"><![CDATA[<p>还记得之前写过的一篇博客，<a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89/" target="_blank" rel="external">egret游戏引擎入门（六）</a> 在说到其中的一个参数<code>userID</code>的位数为18位，在传输过来的时候丧失精准度的问题。当时我跟几个小伙伴对这个问题纠结了一晚上，其实这个问题在犀牛书中就有提到过(第6版，p34，3.1数字)。</p>
<blockquote>
<p>按照JavaScript中的数字格式，能够表示的整数范围是从 <code>-9007199254740992 ~ 9007199254740992</code>，包含边界值。如果使用了超过此范围的整数，则无发保证低位数字的精准度。</p>
</blockquote>
<p>从上面这段文字中我们可以看到，JavaScript语言只能保证数字的长度在16位以内，如果超过16位，则超出的部分会丧失精准度。   </p>
<p>从这里可以看出，基础真的好重要呀，所以近期内会重读犀牛书、高程之类的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[es6变量声明的6种方法]]></title>
      <url>http://zhangshuang.top/es6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E7%9A%846%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>ES5只有两种变量声明的方法，分别是<code>var</code>与<code>function</code>关键字。ES6相比ES5多了<code>let</code>、<code>const</code>、<code>import</code>、<code>class</code>这四个关键字。<br>最早的ES5使用<code>var</code>、<code>function</code>这两个关键字声明的变量会触发变量声明提前，这个大家都很熟悉。但是ES6新增的<code>let</code>、<code>const</code>这两个块级作用域的变量声明关键字则不会。<br><a id="more"></a></p>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p>在代码块内，使用<code>let</code>关键字声明变量之前，该变量都是不可使用的，也就是在这个代码块内，只要声明的该变量，但是在该变量声明之前调用了，就会报错。这在语法上称为“暂时性死区(参照阮一峰的ES6入门，见下例：)。”<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    console.log(b); //ReferenceError</div><div class="line">    let b = 123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>使用<code>const</code>关键字声明变量的作用域也是块级作用域，但是<code>const</code>与<code>let</code>还是有着非常明显的区别的：使用<code>let</code>关键字声明的变量，它的值可以改变；使用<code>const</code>关键字声明的变量，它的值可以改变，但是变量所指向的内存中的地址是不可改变的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    const a = &#123;</div><div class="line">        p: 123,</div><div class="line">        d: 234</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    a.f = 345;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述代码是不会出错的。但是如下操作是会报错的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    const a = &#123;</div><div class="line">        a: 123</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    a = &#123; // TypeError: Assignment to constant variable</div><div class="line">        b: 234</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个就是改变了常量a在内存中的地址。</p>
<h4 id="import"><a href="#import" class="headerlink" title="import"></a>import</h4><p>import 是用于在一个模块中加载另一个含有export的模块。写法如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">import React from &apos;react&apos;;</div><div class="line">或</div><div class="line">import React, &#123; Component &#125; from &apos;react&apos;;</div></pre></td></tr></table></figure></p>
<p>前面的这个<code>React</code>实际是自己定义的一个要引入文件的名称，也就相当于声明变量。这个就是引入react模块并命名为React，从react中引入React以及Component。</p>
<h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><p>es6引入了class（类）这个概念，使其看起来更加像传统的面向对象的语言例如java或者C++。通过<code>class</code>关键字，可以定义类(声明或定义了一个对象)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person() &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类里面还有构造方法（constructor），这个就不在这里描述了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[HTTP请求的GET与POST]]></title>
      <url>http://zhangshuang.top/HTTP%E8%AF%B7%E6%B1%82%E7%9A%84GET%E4%B8%8EPOST/</url>
      <content type="html"><![CDATA[<p>最近跟公司后端的小伙伴们沟通才知道，原来后端在面试的时候，也经常会遇到GET、POST这样的问题。<br>HTTP请求GET方法和POST方法有什么区别？<br>感觉把区别都说了出来，但是当问题在深入一点的时候，发现自己只是知道了结果，但是不知道原理。看来以后还要在知识的深度上狠下功夫。不都说了，下面就深入了解一下GET方法和POST方法的区别吧。<br><a id="more"></a></p>
<h4 id="HTTP的请求类型"><a href="#HTTP的请求类型" class="headerlink" title="HTTP的请求类型"></a>HTTP的请求类型</h4><p>GET方法与POST方法都是HTTP的请求类型，另外还有两种平常用的不多的PUT（更新）、DELETE（删除）类型。</p>
<h4 id="区别一："><a href="#区别一：" class="headerlink" title="区别一："></a>区别一：</h4><p>GET方法是从指定的资源请求数据，POST方法是向指定的资源提交要处理的数据。</p>
<h4 id="区别二："><a href="#区别二：" class="headerlink" title="区别二："></a>区别二：</h4><p>GET方法请求有长度限制，POST方法请求没有长度限制。<br>这个理解起来比较简单，因为在发送数据时，GET方法是在url的末尾拼接数据，而url的长度是有限的，最长2048个字符，这个限制要根据不同的浏览器厂商而定。而POST方法是在HTTP的消息主体(request body)中发送的，所以没有限制。</p>
<h4 id="区别三："><a href="#区别三：" class="headerlink" title="区别三："></a>区别三：</h4><p>GET方法因为请求的数据是拼接在url中的，所以存书签的时候能够储存。而POST方法则不行。</p>
<h4 id="区别四："><a href="#区别四：" class="headerlink" title="区别四："></a>区别四：</h4><p>GET方法不如POST方法安全。<br>GET方法发送的数据是拼接在url上的，所以发送的信息都是可见的，并且参数会保留在浏览器的历史中，可以被缓存，所以不安全。而POST方法请求的参数不会被保存在浏览器历史或者web服务器日志中。</p>
<h4 id="区别五："><a href="#区别五：" class="headerlink" title="区别五："></a>区别五：</h4><p>GET方法点击后退或者刷新按钮时不会有操作。而POST方法的数据会重新提交。</p>
<h4 id="区别六："><a href="#区别六：" class="headerlink" title="区别六："></a>区别六：</h4><p>编码类型不一样：<br>GET方法使用的编码类型是：<code>application/x-www-form-urlencoded</code>；POST方法使用的编码类型是：<code>application/x-www-form-urlencoded</code>或<code>multipart/form-data</code>，为二进制数据使用多重编码。</p>
<h4 id="区别七："><a href="#区别七：" class="headerlink" title="区别七："></a>区别七：</h4><p>数据类型不一样：<br>GET方法只允许ASCII字符。POST方法没有限制，也允许二进制数据。</p>
<h4 id="区别八："><a href="#区别八：" class="headerlink" title="区别八："></a>区别八：</h4><p>GET方法是幂等的，POST方法是非幂等的。<br>再引入幂等的概念</p>
<blockquote>
<p>在编程中.一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些函数不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.    </p>
</blockquote>
<h4 id="区别九："><a href="#区别九：" class="headerlink" title="区别九："></a>区别九：</h4><p>GET方法无副作用，POST方法有副作用。<br>副作用是指，在发送完一个请求后，网站上的资源状态没有发生修改。比如注册新用户，发生了改变，就是有副作用。而请求用户数据，数据没有发生改变，就是没有副作用。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ol>
<li><a href="http://www.jianshu.com/p/49ebc4a78474" target="_blank" rel="external">HTTP head请求</a>  </li>
<li><a href="https://www.zhihu.com/question/27622127" target="_blank" rel="external">post和get请求的区别</a>  </li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js作用域]]></title>
      <url>http://zhangshuang.top/js%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h5 id="引：Engine-Scope-Conversation"><a href="#引：Engine-Scope-Conversation" class="headerlink" title="引：Engine/Scope Conversation"></a>引：Engine/Scope Conversation</h5><p><img src="https://ooo.0o0.ooo/2017/03/24/58d4b5ac11a2d.png" alt="Engine/Scope Conversation"><br>from <a href="https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md#enginescope-conversation" target="_blank" rel="external">You Don’t Know JS: Scope &amp; Closures</a><br>这一章节，生动详细的向我们描述了js解析引擎是如何运行的，这对理解我们的作用域非常有帮助，有兴趣的可以瞅一眼。下面通过几个简单的题来巩固一下。</p>
<h5 id="1-下面代码alert显示的内容是什么？"><a href="#1-下面代码alert显示的内容是什么？" class="headerlink" title="1.下面代码alert显示的内容是什么？"></a>1.下面代码<code>alert</code>显示的内容是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function a() &#123;</div><div class="line">    var foo = 1;</div><div class="line">    b();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function b() &#123;</div><div class="line">    alert(foo);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function c() &#123;</div><div class="line">    var foo = 1;</div><div class="line">    d();</div><div class="line">    function d() &#123;</div><div class="line">        alert(foo);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a();</div><div class="line">c();</div></pre></td></tr></table></figure>
<p>这道题主要考察的是js中变量的作用域的问题。运行<code>a()</code>，得到的结果是<code>foo is not defined</code>，且程序停止，不会再执行<code>c()</code>，如果把<code>a()</code>注释掉的话，会<code>alert(1)</code>。<br><code>function a(){}</code>中声明的变量<code>foo</code>是局部变量，无法被外界访问，所以<code>function b(){}</code>会报错。<br>    <a id="more"></a><br>而<code>function d(){}</code>中的<code>foo</code>虽然也是局部变量，但是<code>foo</code>的作用域恰好包括了<code>function d(){}</code>，所以这个<code>foo</code>可以找到。</p>
<h5 id="2-下面代码console显示的内容是什么？"><a href="#2-下面代码console显示的内容是什么？" class="headerlink" title="2.下面代码console显示的内容是什么？"></a>2.下面代码<code>console</code>显示的内容是什么？</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var scope=&quot;global&quot;;  </div><div class="line">function t()&#123;  </div><div class="line">    console.log(scope);  </div><div class="line">    var scope = &quot;local&quot;;</div><div class="line">    console.log(scope);  </div><div class="line">&#125;  </div><div class="line">t();</div></pre></td></tr></table></figure>
<p>有些童鞋想当然的认为，因为代码还没有执行到<code>var scope = &quot;local&quot;</code>，所以第一个显示的内容是<code>global</code>，第二个是<code>local</code>。<br>然而事实却不是这样的，第一个显示的内容是<code>undefined</code>。如果按照js解析引擎去解读这段代码，应该可以这样去理解：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var scope; //只是知道有这个变量，还没有进行赋值</div><div class="line">function t() &#123;&#125; //函数声明提前</div><div class="line">t(); //执行这个方法</div><div class="line">function t() &#123; //开始观察方法的内部</div><div class="line">    var scope; //这个是局部变量，变量声明提前</div><div class="line">    console.log(scope); //没有赋值，所以为undefined</div><div class="line">    scope = &quot;local&quot;; //对局部变量进行赋值</div><div class="line">    console.log(scope; //显示为 local</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="3-es5跟es6的作用域区别"><a href="#3-es5跟es6的作用域区别" class="headerlink" title="3.es5跟es6的作用域区别"></a>3.es5跟es6的作用域区别</h5><p>在es5中，是没有块级作用域这个概念的，只有函数作用域，下面的这个例子就可以说明：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var name=&quot;global&quot;;  </div><div class="line">if(true)&#123;  </div><div class="line">    var name=&quot;local&quot;;  </div><div class="line">    console.log(name)  </div><div class="line">&#125;  </div><div class="line">console.log(name);</div></pre></td></tr></table></figure></p>
<p>这里的两个<code>console</code>显示的内容都是<code>local</code>，因为如果有块级作用域的话，第二个<code>console</code>出来的内容应该是<code>global</code>，但是<code>name</code>这个变量被<code>if</code>中的<code>name</code>给覆盖了。<br>es6中，多了<code>let</code>这个声明变量的关键字，使用<code>let</code>声明变量的作用域是块级作用域。还是上面es5中的代码，我们将<code>if</code>中的<code>var</code>变为<code>let</code>看一下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var name=&quot;global&quot;;  </div><div class="line">if(true)&#123;  </div><div class="line">    let name=&quot;local&quot;;  </div><div class="line">    console.log(name)  </div><div class="line">&#125;  </div><div class="line">console.log(name);</div></pre></td></tr></table></figure></p>
<p>这时，<code>console</code>出来的内容就是<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">local</div><div class="line">global</div></pre></td></tr></table></figure></p>
<p>这就证实了，使用<code>let</code>声明变量的作用域是块级作用域。</p>
<h5 id="4-为下面html中每一个li添加点击事件，点击alert出自己为ul中的第几个。"><a href="#4-为下面html中每一个li添加点击事件，点击alert出自己为ul中的第几个。" class="headerlink" title="4.为下面html中每一个li添加点击事件，点击alert出自己为ul中的第几个。"></a>4.为下面html中每一个li添加点击事件，点击<code>alert</code>出自己为ul中的第几个。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;内容&lt;/li&gt;</div><div class="line">    &lt;li&gt;内容&lt;/li&gt;</div><div class="line">    &lt;li&gt;内容&lt;/li&gt;</div><div class="line">    &lt;li&gt;内容&lt;/li&gt;</div><div class="line">    &lt;li&gt;内容&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>下面代码中是否有问题？如果有应该如何改善？<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var liList = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">for(var i = 0, li; li = liList[i]; i++) &#123;</div><div class="line">    li.addEventListener(&apos;click&apos;, function() &#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;, false);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这道题有两个问题，第一个是for循环的写法上存在问题，没有说明i的最大值是多少；第二个问题是根据js中变量的作用域链来看，<code>i</code>在这个匿名函数中没有声明，所以会去外面找，但是这个i因为没有最大值，一直++，所以也不会知道i是多少。<br>应该使用如下方法去写：<br>方法一：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var liList = document.getElementsByTagName(&apos;li&apos;);</div><div class="line">for(var i = 0, len = liList.length; i &lt; len; i++) &#123;</div><div class="line">    (function (i) &#123;</div><div class="line">        liList[i].addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;);</div><div class="line">    &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方法使用闭包的方式，将i传入。不会出现每次调用因为匿名函数中找不到i，去外部找，i已经加到最大值的情况。<br>方法二：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(let i = 0, len = liList.length; i &lt; len; i++) &#123;</div><div class="line">    liList[i].addEventListener(&apos;click&apos;, function () &#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>使用es6的块级作用域解决。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[浏览器兼容问题【转】]]></title>
      <url>http://zhangshuang.top/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E3%80%90%E8%BD%AC%E3%80%91/</url>
      <content type="html"><![CDATA[<h4 id="1-ie6-0横向margin加倍"><a href="#1-ie6-0横向margin加倍" class="headerlink" title="1. ie6.0横向margin加倍"></a>1. ie6.0横向margin加倍</h4><p>产生因素：块属性、float、有横向margin。<br>解决方法：display：inline；</p>
<h4 id="2-ie6-0下默认有行高"><a href="#2-ie6-0下默认有行高" class="headerlink" title="2. ie6.0下默认有行高"></a>2. ie6.0下默认有行高</h4><p>解决方法：overflow:hidden;或font-size:0;或line-height：xx px；</p>
<h4 id="3-在各个浏览器下img有空隙-原因是：回车。"><a href="#3-在各个浏览器下img有空隙-原因是：回车。" class="headerlink" title="3. 在各个浏览器下img有空隙(原因是：回车。)"></a>3. 在各个浏览器下img有空隙(原因是：回车。)</h4><a id="more"></a>
<p>解决方法:让图片浮动。</p>
<h4 id="4-一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。"><a href="#4-一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。" class="headerlink" title="4. 一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。"></a>4. 一个父标签与几个子标签嵌套，父标签不浮动，子标签float，子标签不撑开父的高度。</h4><p>解决方法：a 在子标签最后清浮动<br><code>{
    &lt;div style=&quot;height:0;clear:both;&quot;&gt;
    &amp;nbsp;
    &lt;/div&gt;
}</code><br>b 父标签添加<code>{overflow：hidden；}</code><br>c 给父标签设置高度</p>
<h4 id="5-Ie6下，不识别最大宽、高度和最小宽高度，意即min-width-height和-Max-width-height在ie6中没效果，"><a href="#5-Ie6下，不识别最大宽、高度和最小宽高度，意即min-width-height和-Max-width-height在ie6中没效果，" class="headerlink" title="5. Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果，"></a>5. Ie6下，不识别最大宽、高度和最小宽高度，意即min-width/height和 Max-width/height在ie6中没效果，</h4><p>解决方法：<br>(1)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.abc&#123;border:1px blue solid;width:200px;height:200px;&#125;</div><div class="line">html&gt;body .abc&#123;width:auto;height:auto;min-width:200px;min-height:200px;&#125;</div></pre></td></tr></table></figure></p>
<p>(2)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.abc&#123;width:200px;height:200px;_width:200px;_height:200px;&#125;</div></pre></td></tr></table></figure></p>
<p>（因为ie6有一个特征，当定义一个高度时，如果内容超过高度，元素会自动调整高度。）</p>
<h4 id="6-Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距"><a href="#6-Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距" class="headerlink" title="6. Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距"></a>6. Ie6里面：如li设宽、高，并且li里面的标签浮动，那么li之间会有间距</h4><p>解决方法：li不设宽、高或者li内的标签不浮动</p>
<h4 id="7-li之间有间距"><a href="#7-li之间有间距" class="headerlink" title="7. li之间有间距"></a>7. li之间有间距</h4><p>解决方法：li 设置<code>vertical-align:middle;</code><br>8 3像素问题：ie6下，当浮动元素与流动元素并列显示时，他们之间会存在三像素问题。<br>解决方法：用hack技术， 例如：所有浏览器通用 <code>height:100px;</code><br>ie6专用<code>_height:100px;</code><br>ie7专用<code>*+height:100px;</code><br>ie6/ie7共用<code>*height:100px;</code></p>
<h4 id="9-当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。"><a href="#9-当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。" class="headerlink" title="9. 当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。"></a>9. 当定义行内元素为包含框时，且包含框包含的绝对定位元素以百分比为单位进行定位时，会出现混乱。</h4><pre><code>解决方法：在行内元素里加入`{zoom：1；}`
</code></pre><h4 id="10-当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100-，则在下一行多显示一个上一行最后一个字符。"><a href="#10-当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100-，则在下一行多显示一个上一行最后一个字符。" class="headerlink" title="10. 当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。"></a>10. 当多个浮动元素中间夹杂着HTML注释语句时，如果浮动元素宽度为100%，则在下一行多显示一个上一行最后一个字符。</h4><p>解决办法：给浮动元素添加<code>display:inline;</code>。</p>
<h4 id="11-opacity-定义元素的不透明度"><a href="#11-opacity-定义元素的不透明度" class="headerlink" title="11. opacity 定义元素的不透明度"></a>11. opacity 定义元素的不透明度</h4><p><code>filter：alpha（opacity=80）；/*ie支持该属性*/</code><br><code>opacity：0.8；/*支持css3的浏览器*/</code></p>
<h4 id="12-两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。"><a href="#12-两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。" class="headerlink" title="12. 两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。"></a>12. 两个块元素，竖向的margin值不增加，会重叠，其间距为最大margin值。</h4><h4 id="13-优先级："><a href="#13-优先级：" class="headerlink" title="13. 优先级："></a>13. 优先级：</h4><p>被!important 注明的css属性具有最高优先级<code>(.abc{color:red !important;})</code>。但在ie6中!important具有一个bug:在同一组css属性中，!important不起作用。</p>
<h4 id="14-火狐不识别background-position-y-或background-position-x"><a href="#14-火狐不识别background-position-y-或background-position-x" class="headerlink" title="14. 火狐不识别background-position-y 或background-position-x;"></a>14. 火狐不识别background-position-y 或background-position-x;</h4><h4 id="15-ie6-不支持-fixed"><a href="#15-ie6-不支持-fixed" class="headerlink" title="15. ie6 不支持 fixed"></a>15. ie6 不支持 fixed</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*对于非IE6可以这样写*/</div><div class="line">#top&#123;  </div><div class="line">    position:fixed;  </div><div class="line">    bottom:0;  </div><div class="line">    right:20px;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/*但是IE6是不支持fixed定位的，需要另外重写*/</div><div class="line">#top&#123;  </div><div class="line">    position:fixed;  </div><div class="line">    _position:absolute;  </div><div class="line">    top:0;  </div><div class="line">    right:20px;  </div><div class="line">    _bottom:auto;  </div><div class="line">    _top:expression(eval(document.documentElement.scrollTop));</div><div class="line">&#125;  </div><div class="line"></div><div class="line">/*使用hack使IE6实现该效果，但这个东东会闪烁，需要以下代码*/</div><div class="line">*html&#123;  </div><div class="line">    background-image:url(about:blank);  </div><div class="line">    background-attachment:fixed;  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/*使固定在顶部*/</div><div class="line">#top&#123;  </div><div class="line">    _position:absolute;  </div><div class="line">    _bottom:auto;  </div><div class="line">    _top:expression(eval(document.documentElement.scrollTop));  </div><div class="line">&#125;  </div><div class="line"></div><div class="line">/*固定在底部*/</div><div class="line">#top&#123;  </div><div class="line">    _position:absolute;  </div><div class="line">    _bottom:auto;  </div><div class="line">    _top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight-this.offsetHeight-(parseInt(this.currentStyle.marginTop)||0)-(parseInt(this.currentStyle.marginBottom)||0)));  </div><div class="line">&#125;  </div><div class="line">/*垂直居中*/</div><div class="line">#top&#123;</div><div class="line">    position:fixed;</div><div class="line">    top:50%;</div><div class="line">    margin-top:-50px;</div><div class="line">    _position:absolute;</div><div class="line">    _top:expression(eval(document.documentElement.scrollTop+document.documentElement.clientHeight/2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="16-解决-ie6-最大、最小宽高-hack方法"><a href="#16-解决-ie6-最大、最小宽高-hack方法" class="headerlink" title="16.  解决 ie6 最大、最小宽高 hack方法"></a>16.  解决 ie6 最大、最小宽高 hack方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/* 最小宽度 */</div><div class="line">.min_width&#123;</div><div class="line">    min-width:300px;</div><div class="line">    _width:expression(parseInt(this.clientWidth) &lt; 300 ? &quot;300px&quot; : this.clientWidth);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 最大宽度 */</div><div class="line">.max_width&#123;</div><div class="line">   max-width:600px;</div><div class="line">   _width:expression(parseInt(this.clientWidth) &gt; 600 ? &quot;600px&quot; : this.clientWidth);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 最小高度 */</div><div class="line">.min_height&#123;</div><div class="line">   min-height:200px;</div><div class="line">   _height:expression(parseInt(this.clientHeight) &lt; 200 ? &quot;200px&quot; : this.clientHeight);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/* 最大高度 */</div><div class="line">.max_height&#123;</div><div class="line">   max-height:400px;</div><div class="line">   _height:expression(parseInt(this.clientHeight) &gt; 400 ? &quot;400px&quot; : this.clientHeight);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="17-z-index不起作用的-bug"><a href="#17-z-index不起作用的-bug" class="headerlink" title="17.  z-index不起作用的 bug"></a>17.  z-index不起作用的 bug</h4><p>1）ie6下 首先讲讲第一种z-index无论设置多高都不起作用情况。这种情况发生的条件有三个：1、父标签position属性为relative；2、问题标签含有浮动(float)属性。<br>2）所有浏览器：它只认第一个爸爸<br>层级的高低不仅要看自己，还要看自己的老爸这个后台是否够硬。用术语具体描述为：<br>父标签position属性为relative或absolute时，子标签的absolute属性是相对于父标签而言的。而在IE6下，层级的表现有时候不是看子标签的z-index多高，而要看它们的父标签的z-index谁高谁低。</p>
<h4 id="18-ie各个版本hack"><a href="#18-ie各个版本hack" class="headerlink" title="18.  ie各个版本hack"></a>18.  ie各个版本hack</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*类内部hack：*/</div><div class="line">    .header &#123;_width:100px;&#125;            /* IE6专用*/</div><div class="line">    .header &#123;*+width:100px;&#125;        /* IE7专用*/</div><div class="line">    .header &#123;*width:100px;&#125;            /* IE6、IE7共用*/</div><div class="line">    .header &#123;width:100px\0;&#125;        /* IE8、IE9共用*/</div><div class="line">    .header &#123;width:100px\9;&#125;        /* IE6、IE7、IE8、IE9共用*/</div><div class="line">    .header &#123;width:330px\9\0;&#125;    /* IE9专用*/</div><div class="line"></div><div class="line">/*选择器Hack：*/</div><div class="line">    *html .header&#123;&#125;        /*IE6*/</div><div class="line">    *+html .header&#123;&#125;    /*IE7*/</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[chrome插件开发]]></title>
      <url>http://zhangshuang.top/chrome%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="Chrome浏览器小插件开发"><a href="#Chrome浏览器小插件开发" class="headerlink" title="Chrome浏览器小插件开发"></a>Chrome浏览器小插件开发</h2><p>跟对象好了六年多，终于领证了，然而还没有求婚…<br>之前看知乎上有个网友说自己没有求婚，然后每次一吵架，他老婆就会拿这个没求婚的事儿出来怼他。看来，求婚的事儿真的是迫在眉睫了呀。<br>但是怎么求婚呢？摆一圈玫瑰、一圈蜡烛、一圈气球？还是…<br>作为一个程序员，还是搞一个看上去很浪漫，又是自己写的东西出来吧。<br>最开始想的是做个app，虽然自己是web前端，但是用之前工作中用过的egret或者也有其他的打包工具也可以打包成ios的app。但是这个周期可能稍微长一些，所以就想到了开发一个chrome的小插件，每当她打开新标签页的时候就能够看到一张精美的图片，一段格言锦句，可以让我一直关心她，哈哈:）<br>下面就说一下这个小插件的做法吧。<br>项目地址：<a href="https://github.com/ZhangShuangV/chrome-plugin" target="_blank" rel="external">https://github.com/ZhangShuangV/chrome-plugin</a><br><a id="more"></a></p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><h4 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h4><p>chrome的插件是由一个名为<code>manifest.json</code>的配置文件定义的，这个跟nodejs的<code>package.json</code>很像，另外还包含了一些html、js、css文件。<br>目录结构大致如下：</p>
<h4 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h4><p>1.基本属性<br>包括插件名称<code>name</code>、版本<code>version</code>、描述<code>description</code>、图标<code>icon</code>、manifest版本<code>manifest_version</code>等等。<br>其中<code>manifest_version</code>必须为<code>2</code>，这个看其他的教程也是这么说的，但是自己试了一下，chrome提示这个字段必须set为2。<br><code>version</code>这个字段，每次在chrome应用商店提交应用的时候，必须更新。我之前第二次上传应用商店的时候，就没有更新这个字段，结果就报错，提示是增加版本号。<br><code>description</code>这个字段是指整个插件的描述，用鼠标指到插件的图标上面显示的内容。<br><code>icon</code>这个字段为插件显示的图标<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;name&quot;: &quot;tabplus&quot;,</div><div class="line">    &quot;version&quot;: &quot;0.1&quot;，</div><div class="line">    &quot;description&quot;: a chrome plug-in for new tab&quot;,</div><div class="line">    &quot;manifest_version&quot;: 2，</div><div class="line">    &quot;icon&quot;: &#123;</div><div class="line">        &quot;128&quot;: &quot;./img/tabplus.png&quot;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2.chrome工具栏提示 browser_action<br><code>browser_action</code> 指定扩展的图标放在 Chrome 工具栏中，它定义了扩展图标文件位置（default_icon）、悬浮提示（default_title）和点击扩展图标所显示的页面位置（default_popup）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;browser_action&quot;: &#123;</div><div class="line">    &quot;default_icon&quot;: &#123;</div><div class="line">        &quot;16&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">        &quot;48&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">        &quot;128&quot;: &quot;./resource/img/tabplus.png&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;default_title&quot;: &quot;a new chrome tab&quot;,</div><div class="line">    &quot;default_popup&quot;: &quot;./page/popup.html&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>我写的这个插件，点开后的效果如下：<br><img src="https://ooo.0o0.ooo/2017/02/27/58b39919c35da.png" alt="chrome工具栏效果"></p>
<p>3.选项页 options_page<br><code>options_page</code> 属性定义了扩展的设置页面，配置后在扩展图标点击右键可以看到 选项，点击即打开指定页面。注意这里面的‘s’。<br><code>&quot;options_page&quot;:&quot;./page/options.html&quot;</code></p>
<p>4.权限 permissions<br><code>permissions</code> 属性是一个数组，它定义了扩展需要向 Chrome 申请的权限，比如通过 XMLHttpRequest 跨域请求数据、访问浏览器选项卡（tabs）、获取当前活动选项卡（activeTab）、浏览器通知（notifications）、存储（storage）等，可以根据需要添加，如果内容涉及到了跨域等问题，都需要在此字段中添加相应的地址。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;permissions&quot;: [</div><div class="line">    &quot;tabs&quot;,</div><div class="line">    &quot;activeTab&quot;,</div><div class="line">    &quot;notifications&quot;,</div><div class="line">    &quot;storage&quot;,</div><div class="line">    &quot;declarativeContent&quot;,</div><div class="line">    &quot;*://www.zhangshuang.top/*&quot;,</div><div class="line">    &quot;*://www.baidu.com/*&quot;</div><div class="line">],</div></pre></td></tr></table></figure></p>
<p>5.自定义页面替换默认页面 chrome_url_overrides<br><code>chrome_url_overrides</code> 属性可以自定义的页面替换 Chrome 相应默认的页面，比如新标签页（newtab）、书签页面（bookmarks）和历史记录（history）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;chrome_url_overrides&quot;: &#123;</div><div class="line">    &quot;newtab&quot;: &quot;./page/tab.html&quot;</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p>
<p>6.在指定网站添加文件 content_scripts<br><code>content_scripts</code> 属性可以帮助我们实现给特定的站点添加特定的文件。例如去除百度搜索广告，我们就可以这么来实现：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&quot;content_scripts&quot;: [&#123;</div><div class="line">    &quot;matches&quot;: [&quot;*://www.baidu.com/*&quot;],</div><div class="line">    &quot;css&quot;: [&quot;./resource/css/noad.css&quot;]</div><div class="line">&#125;]</div></pre></td></tr></table></figure></p>
<p>其中<code>noad.css</code>是自己写的文件，隐藏百度搜索的广告部分。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">#content_left&gt;div:not(.c-container) &#123;</div><div class="line">    height:0;</div><div class="line">    overflow: hidden;</div><div class="line">    margin-bottom: 0;</div><div class="line">&#125;</div><div class="line">#content_left&gt;div.leftBlock, .hit_top_new &#123;</div><div class="line">    height: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>插件开发完成之后，我们还需要进行调试。<br>首先打开 Chrome 设置-扩展程序（chrome://extensions/）页面，勾选 开发者模式，点击 加载正在开发的扩展程序 按钮，选择扩展所在的文件夹，就可以在浏览器工具栏中看到自己写的扩展了。<br>如果该扩展带有图标，右键单击图标，点击 审查弹出内容 即可。</p>
<p>附 manifest.json配置<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;manifest_version&quot;: 2,</div><div class="line">    &quot;name&quot;: &quot;TabPlus&quot;,</div><div class="line">    &quot;description&quot;: &quot;a chrome plug-in for new tab&quot;,</div><div class="line">    &quot;version&quot;: &quot;0.1.2&quot;,</div><div class="line">    &quot;icons&quot;: &#123;</div><div class="line">        &quot;16&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">        &quot;48&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">        &quot;128&quot;: &quot;./resource/img/tabplus.png&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;browser_action&quot;: &#123;</div><div class="line">        &quot;default_icon&quot;: &#123;</div><div class="line">            &quot;16&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">            &quot;48&quot;: &quot;./resource/img/tabplus.png&quot;,</div><div class="line">            &quot;128&quot;: &quot;./resource/img/tabplus.png&quot;</div><div class="line">        &#125;,</div><div class="line">        &quot;default_title&quot;: &quot;a new chrome tab&quot;,</div><div class="line">        &quot;default_popup&quot;: &quot;./page/popup.html&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;options_page&quot;: &quot;./page/options.html&quot;,</div><div class="line">    &quot;permissions&quot;: [</div><div class="line">        &quot;tabs&quot;,</div><div class="line">        &quot;activeTab&quot;,</div><div class="line">        &quot;notifications&quot;,</div><div class="line">        &quot;storage&quot;,</div><div class="line">        &quot;declarativeContent&quot;,</div><div class="line">        &quot;*://www.zhangshuang.top/*&quot;,</div><div class="line">        &quot;*://www.baidu.com/*&quot;</div><div class="line">    ],</div><div class="line">    &quot;homepage_url&quot;: &quot;http://www.zhangshuang.top&quot;,</div><div class="line">    &quot;chrome_url_overrides&quot;: &#123;</div><div class="line">        &quot;newtab&quot;: &quot;./page/tab.html&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;background&quot;: &#123;</div><div class="line">        &quot;scripts&quot;: [&quot;./resource/js/background.js&quot;]</div><div class="line">    &#125;,</div><div class="line">    &quot;content_scripts&quot;: [&#123;</div><div class="line">        &quot;matches&quot;: [&quot;*://www.baidu.com/*&quot;],</div><div class="line">        &quot;css&quot;: [&quot;./resource/css/noad.css&quot;]</div><div class="line">    &#125;]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret绘制环形图]]></title>
      <url>http://zhangshuang.top/egret%E7%BB%98%E5%88%B6%E7%8E%AF%E5%BD%A2%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>之前分享过通过highcarts、echarts绘制饼图(环形图)。前段时间的H5游戏项目中，也通过egret绘制过环形图，下面就分享一下，如何通过egret绘制环形图。</p>
<h4 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h4><p>先看一下效果图<br><img src="https://ooo.0o0.ooo/2017/02/15/58a4121f20226.png" alt="egret绘制环形图"></p>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>这种绘制方法肯定不是只用一次，所以我们需要将这种方法封装到函数中，然后我们通过传入几个参数就可以绘制出环形图。<br><code>function drawCircle(obj, data) {}</code><br><a id="more"></a><br>先来分析一下这个图都有几部分组成。<br>首先我们可以看出环形图的颜色是分为深、浅两种颜色，中间是一个icon，下边部分是图例。</p>
<h4 id="环形图主体部分"><a href="#环形图主体部分" class="headerlink" title="环形图主体部分"></a>环形图主体部分</h4><p>因为不是使用highcharts、echarts这种插件，所以所有的东西都需要我们自己去写，不能使用一些原有的配置。<br>在开始绘制之前，我们需要先算出来这个环形图要绘制成几部分，也就是传入的数据的<code>length</code>是多少，然后我们还需要算出绘制的起始和结束角度<code>startDeg</code>、<code>endDeg</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const length: number = data.length;</div><div class="line">let startDeg = 0;</div><div class="line">let endDeg = 0;</div><div class="line">// 还有一些其他的，如要绘制的图形的宽、高等属性，根据需要自行设置即可</div></pre></td></tr></table></figure></p>
<p>在基本的配置完成后，我们需要先创建一个放置环形图及其图例的区域<code>sprite</code>，下面的<code>objWidth</code>、<code>width</code>为前一步的自行设置，<code>obj</code>为传入的对象，后面就不在单独说明了。如果有不懂的地方，最后也有所有代码的汇总。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let percentBg: egret.Sprite = new egret.Sprite();</div><div class="line">percentBg.width = width;</div><div class="line">percentBg.height = height;</div><div class="line">percentBg.x = (objWidth - width) / 2;</div><div class="line">percentBg.y = 95;</div><div class="line">obj.addChild(percentBg);</div></pre></td></tr></table></figure></p>
<p>环形图的区域跟上面一样，也是创建一个<code>sprite</code>，然后放置到percentBg上面。</p>
<p>通过for循环进行外层浅色区域环形图的绘制，这里面同时也会将<code>startDeg</code>与<code>endDeg</code>分别赋值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for(let i = 0; i &lt; length; i++) &#123;</div><div class="line">    endDeg = (data[i].industryPercent).toFixed(2) * 3.6 + startDeg;</div><div class="line">    circleBg.graphics.beginFill(GameConfig.lightColor[i]);</div><div class="line">    circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">    circleBg.graphics.lineTo(width, width / 2);</div><div class="line">    circleBg.graphics.drawArc(width / 2, width / 2, width / 2.3, (startDeg + 2) * Math.PI / 180, endDeg * Math.PI / 180);</div><div class="line">    circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">    circleBg.graphics.endFill();</div><div class="line">    startDeg = endDeg;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先通过传入数据中的配比情况，算出<code>endDeg</code>结束角度，然后通过egret的绘图API绘制。<br>内层深色区域绘制方法同上，只需要将半径变小即可。<br>绘制完成后，展现在我们面前的是下面的样子<br><img src="https://ooo.0o0.ooo/2017/02/15/58a41bc9a803f.png" alt="只绘制了深色跟浅色区域"><br>这个跟我们的需求还相差很远，这里就需要我们在以同样的圆心，绘制上一个白色的圆形来遮挡住中间的部分。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">circleBg.graphics.beginFill(GameConfig.TextColors.white); //环形图中间白色部分</div><div class="line">circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">circleBg.graphics.lineTo(width, width / 2);</div><div class="line">circleBg.graphics.drawArc(width / 2, width / 2, width / 3.5, 0, 360 * Math.PI / 180);</div><div class="line">circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">circleBg.graphics.endFill();</div></pre></td></tr></table></figure></p>
<p>并且再以同样的圆心，绘制上一个icon。icon因为是固定的，所以建议使用图片<code>Bitmap</code>，因为绘制会比直接使用图片更加消耗性能。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let centerIcon = ZpyGameUtils.createBitmapByName(&quot;card_dark_icon_png&quot;); //中心icon</div><div class="line">centerIcon.x = width / 2 - centerIcon.width / 2 * 0.6;</div><div class="line">centerIcon.y = width / 2 - centerIcon.height / 2 * 0.6;</div><div class="line">centerIcon.scaleX = 0.6;</div><div class="line">centerIcon.scaleY = 0.6;</div><div class="line">circleBg.addChild(centerIcon);</div></pre></td></tr></table></figure></p>
<h4 id="环形图图例"><a href="#环形图图例" class="headerlink" title="环形图图例"></a>环形图图例</h4><p>绘制完主体部分，我们再来绘制一下图例部分。这个相对于主体环形图来说，就很简单了。<code>icon</code>是图例前面的小色块，<code>label</code>是图例文字部分。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let labelBg: egret.Sprite = new egret.Sprite();</div><div class="line">labelBg.width = width - 40;</div><div class="line">labelBg.x = 20;</div><div class="line">labelBg.y = width;</div><div class="line">for (let i = 0, len = data.length; i &lt; len; i++) &#123;</div><div class="line">    let icon: egret.Shape = new egret.Shape();</div><div class="line">    icon.graphics.beginFill(GameConfig.darkColor[i]);</div><div class="line">    icon.graphics.drawRect(0, i * lineHeight, 20, 20);</div><div class="line">    icon.graphics.endFill();</div><div class="line">    labelBg.addChild(icon);</div><div class="line"></div><div class="line">    let label: egret.TextField = ZpyGameUtils.createText(data[i].industryName + &apos;  &apos; + (data[i].industryPercent).toFixed(2) + &apos;%&apos;, GameConfig.TextColors.black, 20);</div><div class="line">    label.x = 30;</div><div class="line">    label.y = lineHeight * i;</div><div class="line">    labelBg.addChild(label);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="可滑动"><a href="#可滑动" class="headerlink" title="可滑动"></a>可滑动</h4><p>因为环形图的数据可能很多，图例一页可能会显示不过来，所以我们还需要一个可以上下滑动的组件来扩展。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let percentTotalBg: egret.Sprite = new egret.Sprite();</div><div class="line">percentTotalBg.width = width;</div><div class="line"></div><div class="line">percentTotalBg.addChild(labelBg);</div><div class="line">percentTotalBg.height = width + length * lineHeight;</div><div class="line"></div><div class="line">var scrollView: egret.ScrollView = new egret.ScrollView();</div><div class="line">scrollView.setContent(percentTotalBg);</div><div class="line">scrollView.width = width;</div><div class="line">scrollView.height = height;</div><div class="line">percentBg.addChild(scrollView);</div></pre></td></tr></table></figure></p>
<p>前面步骤中生成的所元素最终会放置到<code>percentTotalBg</code>上，然后声明一个滑动区域<code>scrollView</code>，通过<code>setContent</code>方法将所有元素的区域设置为可滑动的区域。</p>
<h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function drawCircle(obj, data) &#123;</div><div class="line">    const objWidth: number = obj.width;</div><div class="line">    const objHeight: number = obj.height;</div><div class="line">    const width: number = obj.width * 0.8; //新创建的背景的宽度,宽高相同</div><div class="line">    const height: number = obj.height * 0.8; //新创建的背景的高度</div><div class="line">    const lineHeight: number = 35;</div><div class="line">    const length: number = data.length; //数据长度</div><div class="line">    let startDeg = 0; //扇形起始角度</div><div class="line">    let endDeg = 0; //结束角度</div><div class="line"></div><div class="line">    let percentBg: egret.Sprite = new egret.Sprite();</div><div class="line">    percentBg.width = width;</div><div class="line">    percentBg.height = height;</div><div class="line">    percentBg.x = (objWidth - width) / 2;</div><div class="line">    percentBg.y = 95;</div><div class="line">    obj.addChild(percentBg);</div><div class="line">    let percentTotalBg: egret.Sprite = new egret.Sprite();</div><div class="line">    percentTotalBg.width = width;</div><div class="line">    let circleBg: egret.Sprite = new egret.Sprite();</div><div class="line">    percentTotalBg.addChild(circleBg);</div><div class="line">    circleBg.width = width;</div><div class="line">    circleBg.height = width;</div><div class="line">    circleBg.y = 0;</div><div class="line"></div><div class="line">    for (let i = 0; i &lt; length; i++) &#123; //环形图浅色部分</div><div class="line">        endDeg = (data[i].industryPercent).toFixed(2) * 3.6 + startDeg;</div><div class="line">        circleBg.graphics.beginFill(GameConfig.lightColor[i]);</div><div class="line">        circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.lineTo(width, width / 2);</div><div class="line">        circleBg.graphics.drawArc(width / 2, width / 2, width / 2.3, (startDeg + 2) * Math.PI / 180, endDeg * Math.PI / 180);</div><div class="line">        circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.endFill();</div><div class="line">        startDeg = endDeg;</div><div class="line">    &#125;</div><div class="line">    for (let i = 0; i &lt; length; i++) &#123; //环形图深色部分</div><div class="line">        endDeg = (data[i].industryPercent).toFixed(2) * 3.6 + startDeg;</div><div class="line">        circleBg.graphics.beginFill(GameConfig.darkColor[i]);</div><div class="line">        circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.lineTo(width, width / 2);</div><div class="line">        circleBg.graphics.drawArc(width / 2, width / 2, width / 2.6, (startDeg + 2) * Math.PI / 180, endDeg * Math.PI / 180);</div><div class="line">        circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.endFill();</div><div class="line">        startDeg = endDeg;</div><div class="line">    &#125;</div><div class="line">    circleBg.graphics.beginFill(GameConfig.TextColors.white); //环形图中间白色部分</div><div class="line">    circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">    circleBg.graphics.lineTo(width, width / 2);</div><div class="line">    circleBg.graphics.drawArc(width / 2, width / 2, width / 3.5, 0, 360 * Math.PI / 180);</div><div class="line">    circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">    circleBg.graphics.endFill();</div><div class="line"></div><div class="line">    let centerIcon = ZpyGameUtils.createBitmapByName(&quot;card_dark_icon_png&quot;); //中心icon</div><div class="line">    centerIcon.x = width / 2 - centerIcon.width / 2 * 0.6;</div><div class="line">    centerIcon.y = width / 2 - centerIcon.height / 2 * 0.6;</div><div class="line">    centerIcon.scaleX = 0.6;</div><div class="line">    centerIcon.scaleY = 0.6;</div><div class="line">    circleBg.addChild(centerIcon);</div><div class="line">    percentTotalBg.addChild(circleBg);</div><div class="line"></div><div class="line">    let labelBg: egret.Sprite = new egret.Sprite();</div><div class="line">    labelBg.width = width - 40;</div><div class="line">    labelBg.x = 20;</div><div class="line">    labelBg.y = width;</div><div class="line">    for (let i = 0, len = data.length; i &lt; len; i++) &#123;</div><div class="line">        let icon: egret.Shape = new egret.Shape();</div><div class="line">        icon.graphics.beginFill(GameConfig.darkColor[i]);</div><div class="line">        icon.graphics.drawRect(0, i * lineHeight, 20, 20);</div><div class="line">        icon.graphics.endFill();</div><div class="line">        labelBg.addChild(icon);</div><div class="line"></div><div class="line">        let label: egret.TextField = ZpyGameUtils.createText(data[i].industryName + &apos;  &apos; + (data[i].industryPercent).toFixed(2) + &apos;%&apos;, GameConfig.TextColors.black, 20);</div><div class="line">        label.x = 30;</div><div class="line">        label.y = lineHeight * i;</div><div class="line">        labelBg.addChild(label);</div><div class="line">    &#125;</div><div class="line">    percentTotalBg.addChild(labelBg);</div><div class="line">    percentTotalBg.height = width + length * lineHeight;</div><div class="line"></div><div class="line">    var scrollView: egret.ScrollView = new egret.ScrollView();</div><div class="line">    scrollView.setContent(percentTotalBg);</div><div class="line">    scrollView.width = width;</div><div class="line">    scrollView.height = height;</div><div class="line">    percentBg.addChild(scrollView);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果是在namespace中，请不要忘记通过export方法使其可以在外部访问。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[echarts绘制饼图]]></title>
      <url>http://zhangshuang.top/echarts%E7%BB%98%E5%88%B6%E9%A5%BC%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>之前写过一篇highcharts<a href="">绘制环形配比图</a>，当时boss建议通过highcharts来绘制。但是公司的官网的图表是通过echarts来绘制的，并且这次把这个需求交给了我。所以这次只能再研究一下echarts的绘制饼图的api。<br><a id="more"></a></p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>echarts因为是百度开发的，所以它的API都是中文的，相对较简单一些。<br><img src="https://ooo.0o0.ooo/2017/02/15/58a403c44fe0a.png" alt="需求如本图"><br>如上图所示，本次的需求相对比较简单，只需要展示出配比详情及图例即可。左侧较好实现，右侧如果使用图例legend的话非常麻烦，里面包含了很多小项也包含了很多数据。所以决定右侧还是使用html来写。</p>
<h4 id="为echarts准备一个DOM容器"><a href="#为echarts准备一个DOM容器" class="headerlink" title="为echarts准备一个DOM容器"></a>为echarts准备一个DOM容器</h4><p>创建一个DOM元素，为其取个id名<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;echarts_pie&quot; style=&quot;width:300px;height:300px;&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure></p>
<h4 id="最简单的echarts配置"><a href="#最简单的echarts配置" class="headerlink" title="最简单的echarts配置"></a>最简单的echarts配置</h4><p>首先要通过<code>echarts.init</code>方法，初始化一个echarts实例。这个跟highcharts的<code>$(&quot;#container_pie&quot;).highcharts({})</code>是相似的。这里的<code>echarts_pie</code>就是上一步设置的DOM元素的id名。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var virtualPie = echarts.init($(&quot;#echarts_pie&quot;));</div></pre></td></tr></table></figure></p>
<p>然后配置图表的数据<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var option = &#123;</div><div class="line">    title: &#123; //图表标题</div><div class="line">        text: &apos;资金分配构成&apos;,</div><div class="line">        x: &apos;center&apos;,</div><div class="line">        y: &apos;bottom&apos;,</div><div class="line">        textStyle: &#123;fontSize: &apos;14px&apos;, color: &apos;#999&apos;&#125;,</div><div class="line">        padding: 15</div><div class="line">    &#125;,</div><div class="line">    tooltip: &#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    legend: &#123;</div><div class="line"></div><div class="line">    &#125;,</div><div class="line">    series: [</div><div class="line">        &#123;</div><div class="line">            name: &apos;资金构成&apos;,</div><div class="line">            type: &apos;pie&apos;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的配置项有很多（<a href="http://echarts.baidu.com/option.html#title" target="_blank" rel="external">点击查看更多</a>）。<br>其中图表主元素中的东西，如饼图或者折线图本身，有一些类似<code>min</code>,<code>max</code>,<code>scale</code>这种的属性。图表主元素外的，如图例，提示框这种的都会有<code>show</code>这种是否显示的属性。这一点跟highcharts也是一样的。<br>就比如在这个项目中，legend图例我就用的<code>show: false</code>，然后用DOM元素来替代。<br>另外说一下决定图表样式的<code>series</code>，这个属性中有一项<code>type</code>，这个地方决定了图表的样式是饼图<code>pie</code>、折现图<code>line</code>还是柱形图<code>bar</code>等。其中，如果在一个图表中展示多组数据。<code>series</code>这个地方就需要用数组来标示，每一组数据都用一个对象来标示。<br>再说一下显示组件<code>tooltip</code>。这个是鼠标hover上去之后显示的提示框，这里面显示的内容可以用DOM去编写，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">tooltip : &#123; //显示组件</div><div class="line">    show: true,</div><div class="line">    trigger: &apos;item&apos;,</div><div class="line">    formatter: &quot;&#123;b&#125; : &lt;em style=&quot;position:relative;top:1px;&quot;&gt;&#123;d&#125;&lt;/em&gt;%&quot;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>如果不需要，可以在将属性<code>show</code>设为<code>false</code>。</p>
<p>最后，需要我们将刚刚的option配置，指定为图表的配置<br><code>virtualPie.setOption(option);</code></p>
<p>下面贴一下我的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var initPie = function(data)&#123;</div><div class="line">    var chart = echarts.init($(&apos;#pie&apos;)[0]);</div><div class="line">    var option = &#123;</div><div class="line">        title : &#123;</div><div class="line">            text: &apos;投资资金构成&apos;,</div><div class="line">            x:&apos;center&apos;,</div><div class="line">            y:&apos;bottom&apos;,</div><div class="line">            textStyle: &#123;fontSize: &apos;14px&apos;, color:&apos;#999&apos;&#125;,</div><div class="line">            padding: 15</div><div class="line">        &#125;,</div><div class="line">        tooltip : &#123;</div><div class="line">            trigger: &apos;item&apos;,</div><div class="line">            formatter: &quot;&#123;b&#125; : &lt;em style=&apos;position:relative;top:1px;&apos;&gt;&#123;d&#125;&lt;/em&gt;%&quot;</div><div class="line">        &#125;,</div><div class="line">        legend: &#123;</div><div class="line">            show: false</div><div class="line">        &#125;,</div><div class="line">        series : [</div><div class="line">            &#123;</div><div class="line">                name: &apos;资金构成&apos;,</div><div class="line">                type: &apos;pie&apos;,</div><div class="line">                radius : &apos;60%&apos;,</div><div class="line">                center: [&apos;50%&apos;, &apos;50%&apos;],</div><div class="line">                data: data,</div><div class="line">                label:&#123;</div><div class="line">                    normal: &#123;</div><div class="line">                        show: false,</div><div class="line">                        position: &apos;inside&apos;</div><div class="line">                    &#125;</div><div class="line">                &#125;,</div><div class="line">                itemStyle: &#123;</div><div class="line">                    emphasis: &#123;</div><div class="line">                        shadowBlur: 10,</div><div class="line">                        shadowOffsetX: 0,</div><div class="line">                        shadowColor: &apos;rgba(0, 0, 0, 0.5)&apos;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        ]</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    chart.setOption(option);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[什么是优秀的用户界面设计]]></title>
      <url>http://zhangshuang.top/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>什么是优秀的用户界面设计</p>
<p>今天为大家分享一些 Good UI 在一些项目中获取的设计以及运营策略等方面的经验。</p>
<p>这是本人收藏了很久的干货，最近review笔记，又把它翻出来了。可惜出处是哪忘记了…</p>
<p>Good UI 是一家研究用户体验的设计机构。我们知道成功的页面设计不仅有很高的转化率更便于用户使用，既能满足商业目标更能为用户带来良好的体验。</p>
<ol>
<li><p>用通栏布局代替多栏布局<br><img src="https://ooo.0o0.ooo/2017/02/08/589b20978de27.png" alt="用通栏布局代替多栏布局"></p>
</li>
<li><p>给用户些好处，别急着做生意</p>
<a id="more"></a>
<p><img src="https://ooo.0o0.ooo/2017/02/08/589b20f4ba26b.png" alt="给用户些好处，别急着做生意"></p>
</li>
<li><p>整合相似的功能，去掉零碎的 UI 元素<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2102ac292.png" alt="整合相似的功能，去掉零碎的 UI 元素"></p>
</li>
<li><p>利用社会认同效应，别总是自吹自擂<br><img src="https://ooo.0o0.ooo/2017/02/08/589b210f3366d.png" alt="利用社会认同效应，别总是自吹自擂"></p>
</li>
<li><p>主要功能需要多次强化显示<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2cb95950a.png" alt="主要功能需要多次强化显示"></p>
</li>
<li><p>区分选中和可点击的状态，不要使用户困惑<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ccc6e15f.png" alt="区分选中和可点击的状态，不要使用户困惑"></p>
</li>
<li><p>布局有层次有重点，而非简单罗列<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2cd5b5439.png" alt="布局有层次有重点，而非简单罗列"></p>
</li>
<li><p>允许用户撤销操作而不是使用弹窗需要用户确认<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ce18e8e1.png" alt="允许用户撤销操作而不是使用弹窗需要用户确认"></p>
</li>
<li><p>明确的告知用户适用人群而不是简单的面向所用用户<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2cfe50f82.png" alt="明确的告知用户适用人群而不是简单的面向所用用户"></p>
</li>
<li><p>简洁明了，直接了当<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2d0930e4d.png" alt="简洁明了，直接了当"></p>
</li>
<li><p>页面上多使用对比的方法<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2d78ccb5d.png" alt="页面上多使用对比的方法"></p>
</li>
<li><p>直接标出产地，别总单纯的讲历史<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2d8315076.png" alt="1278339f5db0a1.png"></p>
</li>
<li><p>使用简洁的表单<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2d8e60583.png" alt="使用简洁的表单"></p>
</li>
<li><p>把选项列出来而不是藏起来<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2d99eefcf.png" alt="把选项列出来而不是藏起来"></p>
</li>
<li><p>使用连续性的提示符，别让用户误以为页面到了终点<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2dad41151.png" alt="使用连续性的提示符，别让用户误以为页面到了终点"></p>
</li>
<li><p>功能专一而不是使用太多的链接<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2dcc9780b.png" alt="功能专一而不是使用太多的链接"></p>
</li>
<li><p>提示体统状态<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2dddb9d85.png" alt="提示体统状态"></p>
</li>
<li><p>在动作按钮上增加些吸引人的诱惑<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2df644f37.png" alt="在动作按钮上增加些吸引人的诱惑"></p>
</li>
<li><p>用直接操作来代替无数个菜单<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e0352f4d.png" alt="用直接操作来代替无数个菜单"></p>
</li>
<li><p>直接显示输入框可以省略一个页面<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e10d020a.png" alt="直接显示输入框可以省略一个页面"></p>
</li>
<li><p>用一些动效过度而不用立即显示变化<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e197a26d.png" alt="用一些动效过度而不用立即显示变化"></p>
</li>
<li><p>循序渐进的引导用户而非生硬的要求用户注册<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e4bb9999.png" alt="循序渐进的引导用户而非生硬的要求用户注册"></p>
</li>
<li><p>试着减少线框，减少不必要的注意<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e5459e17.png" alt="试着减少线框，减少不必要的注意"></p>
</li>
<li><p>向用户展示功能上的便捷之处而不是泛泛的展示特性<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e5e7b4d7.png" alt="向用户展示功能上的便捷之处而不是泛泛的展示特性"></p>
</li>
<li><p>用户没有使用记录的时候要善于引导<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e68eb4e9.png" alt="用户没有使用记录的时候要善于引导"></p>
</li>
<li><p>给出默认的选项而不需要用户选择<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e709cbdc.png" alt="给出默认的选项而不需要用户选择"></p>
</li>
<li><p>保持一致性降低用户的学习成本<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e7b10130.png" alt="保持一致性降低用户的学习成本"></p>
</li>
<li><p>自动补全一些数据，降低用户的操作负担<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e846c645.png" alt="自动补全一些数据，降低用户的操作负担"></p>
</li>
<li><p>尊重用户的使用习惯而不是创造新的规则<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2e9fa6160.png" alt="尊重用户的使用习惯而不是创造新的规则"></p>
</li>
<li><p>提示用户如何规避风险，而不是总想着如何获利<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ea9ab06f.png" alt="提示用户如何规避风险，而不是总想着如何获利"></p>
</li>
<li><p>善于引导用户的视觉浏览线，而非单一布局<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2eb1ac0d8.png" alt="善于引导用户的视觉浏览线，而非单一布局"></p>
</li>
<li><p>将相关的条目分组，不要杂乱无章的排列<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ebc69c79.png" alt="将相关的条目分组，不要杂乱无章的排列"></p>
</li>
<li><p>采用及时校验而不是到最后才提示错误<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ec560aad.png" alt="采用及时校验而不是到最后才提示错误"></p>
</li>
<li><p>需要用户输入的格式宽松严格限定格式<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ecce07b1.png" alt="需要用户输入的格式宽松严格限定格式"></p>
</li>
<li><p>让用户有一些紧急的意识，别让用户拖得太久<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ed61a72c.png" alt="让用户有一些紧急的意识，别让用户拖得太久"></p>
</li>
<li><p>适当尝试饥饿营销<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2edf84edb.png" alt="适当尝试饥饿营销"></p>
</li>
<li><p>帮助用户识别<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2ee949317.png" alt="帮助用户识别"></p>
</li>
<li><p>使用更大的点击区域<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2efac0e71.png" alt="使用更大的点击区域"></p>
</li>
<li><p>增加加载的速度，别让用户等太久<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2f01882a4.png" alt="增加加载的速度，别让用户等太久"></p>
</li>
<li><p>可以给用户提供一些快捷操作<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2f15b1a3b.png" alt="可以给用户提供一些快捷操作"></p>
</li>
<li><p>使用一些对比<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2f202af98.png" alt="使用一些对比"></p>
</li>
<li><p>初始化的时候给用户一些激励<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2f2addd77.png" alt="初始化的时候给用户一些激励"></p>
</li>
<li><p>循序渐进地引导用户，不要简单粗暴地直接呈现给用户<br><img src="https://ooo.0o0.ooo/2017/02/08/589b2f382bb85.png" alt="循序渐进地引导用户，不要简单粗暴地直接呈现给用户"></p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript初试（四）]]></title>
      <url>http://zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89%20/</url>
      <content type="html"><![CDATA[<p>其实之前写js的时候，很少使用继承、原型这种东东。但是在开发游戏的时候，发现这个得到了大量的使用。特别是最开始不会的时候，后端童鞋不厌其烦的给我讲private、public、static等等，先感谢一下公司后端童鞋的技术支持，哈哈。<br>其实es6中，已经有了class，但是平常的项目中还是用的较早版本的js。而在ts的使用中，class作为原生支持的写法，使得我们能够更好的开发。<br><a id="more"></a></p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><h5 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h5><p>如果之前接触过java的童鞋肯定会更觉得，下面的代码跟java非常的相像。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    private name: string;</div><div class="line"></div><div class="line">    public constructor(name: string) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public speakName() &#123;</div><div class="line">        return &apos;My name is&apos; + this.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var zhangshuang: Person = new Person(&apos;zhangshuang&apos;);</div></pre></td></tr></table></figure></p>
<p>我们声明了一个类’Person’，这个类里面有三个成员分别是私有变量’name’，构造函数’constructor’,方法’speakName’;<br>先不用管private跟public，当我们发现this的时候，就可以说明这个变量或者方法是属于’Person’这个类的。<br>最后一行，通过’new’关键字，我们构造了一个’Person’类的实例。</p>
<h5 id="修饰符-private-public"><a href="#修饰符-private-public" class="headerlink" title="修饰符 private public"></a>修饰符 private public</h5><h6 id="private-私有"><a href="#private-私有" class="headerlink" title="private 私有"></a>private 私有</h6><p>我们法相上面的例子中，声明变量’name’时，我们使用了private这个关键字。<br>当我们使用’private’声明变量时，该变量只能在类的内部使用，也就是这个变量是这个类的私有成员，外部或者实例化时不可以调用。</p>
<h6 id="public-公有"><a href="#public-公有" class="headerlink" title="public 公有"></a>public 公有</h6><p>在上面的例子中，我们使用’public’关键字写了一个方法。通过’public’修饰的成员是公有的，可以通过外部或者实例化来调用。如果我们不用’public’修饰的话，变量或者方法默认就是’public’(公有)的。</p>
<h6 id="protected-受保护的"><a href="#protected-受保护的" class="headerlink" title="protected 受保护的"></a>protected 受保护的</h6><p>‘protected’作为一个修饰关键字，跟private很类似，但是有一点不同。通过’protected’修饰的成员在派生类中依然可以使用。扒一个例子：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    protected name: string;</div><div class="line">    constructor(name: string) &#123; this.name = name; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Employee extends Person &#123;</div><div class="line">    private department: string;</div><div class="line"></div><div class="line">    constructor(name: string, department: string) &#123;</div><div class="line">        super(name)</div><div class="line">        this.department = department;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public getElevatorPitch() &#123;</div><div class="line">        return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let howard = new Employee(&quot;Howard&quot;, &quot;Sales&quot;);</div><div class="line">console.log(howard.getElevatorPitch());</div><div class="line">console.log(howard.name); // error</div></pre></td></tr></table></figure></p>
<p>我们不能在’Person’类外使用name，但是可以在继承自’Person’类的’Employee’类中使用。</p>
<h5 id="静态属性-static"><a href="#静态属性-static" class="headerlink" title="静态属性 static"></a>静态属性 static</h5><p>在使用类或者其内部的方法时，我们一般都会实例化一个，然后再调用方法。但是当我们把一个变量或者方法的属性设置为static时，就可省去实例化的步骤，直接调用。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    public static name: string = &apos;person&apos;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h5><p>在游戏开发中，有些类如场景等，我们是不希望出现多个的，所以这里使用单例模式开发会避免重复实例化同一个类出现的问题。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class MainView &#123;</div><div class="line"></div><div class="line">    private static instance: MainView;</div><div class="line"></div><div class="line">    public static getInstance() : MainView &#123;</div><div class="line">        if(MainView.instance == null) &#123;</div><div class="line">            MainView.instance = new MainView();</div><div class="line">        &#125;</div><div class="line">        ruturn MainView.instance;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是通过判断instance这个属性是否为null，如果是null则实例化一个类，如果不为null则直接ruturn instance</p>
<h5 id="继承-extends"><a href="#继承-extends" class="headerlink" title="继承 extends"></a>继承 extends</h5><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Person &#123;</div><div class="line">    private name: string;</div><div class="line"></div><div class="line">    public constructor(name: string) &#123;</div><div class="line">        this.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public speakName() &#123;</div><div class="line">        return &apos;My name is&apos; + this.name;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Student extends Person &#123;</div><div class="line">    public constructor() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public grade: number;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子中，我们先声明了一个类Person，然后又声明了一个类Student继承自Person类。<br>构造函数中的<code>super()</code>标示，这个类继承了原型中的所有的方法和属性。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript初试（三）]]></title>
      <url>http://zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>之前在js中，为了防止全局变量污染，我们经常会声明一个对象，然后将变量或者函数作为对象的一个属性存在。<br>但是在ts中，我们可以通过关键字<code>namespace</code>来解决这个问题。<br>这里的namespace相当于es6中的module。<br><a id="more"></a></p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>下面通过一个例子来说明一下<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">namespace gameConfig = &#123;</div><div class="line"></div><div class="line">    export const TextColor = &#123;</div><div class="line">        valueGolden: 0xf7b44a, //净值数值颜色</div><div class="line">        transparent: 0x00000000, //透明色</div><div class="line">        btnGolden: 0xffe8a9 //按钮上的文字的颜色</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export enum errorMsg = &#123;</div><div class="line">        &quot;网络连接故障，请耐心等待&quot; = 5000,</div><div class="line">        &quot;账号在其他位置登录，如不是本人请更改密码&quot; = 5001</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export let isProto: boolean = false;</div><div class="line"></div><div class="line">    let a;</div><div class="line"></div><div class="line">    export function curHeight(): number &#123;</div><div class="line">        //当前游戏宽度</div><div class="line">        console.log(a);</div><div class="line">        return egret.MainContext.instance.stage.stageHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    export class Card&#123;</div><div class="line">        console.log(&apos;this is a card&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">class Example &#123;</div><div class="line">    const gold = gameConfig.TextColor.valueGolden;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在namespace命名空间中，我们可以声明变量，编写函数，编写类等等。<br>当我们在变量声明或者函数、类的编写之前使用export关键字后，我们就可以在命名空间之外找到它。当然有一些内部使用的，我们没有必要使用export关键字。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript初试（二）]]></title>
      <url>http://zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在js中，变量的声明一般用var，但是在上一次分享中大家可能也看到了，当时采用的变量声明的关键字为<code>let</code>。那么这个let是个什么东西呢？<br>let 是es6新增的一个变量声明关键字，用来声明局部变量。同时let也是ts中推荐的声明变量的关键字。let声明的变量是局部变量，它的作用于是块级作用域。<br><a id="more"></a></p>
<p>有一个比较好的例子可以让我们清楚的了解<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (var i = 0; i &lt; 10; i++) &#123;</div><div class="line">    setTimeout(function() &#123; console.log(i); &#125;, 100 * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码的执行结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div><div class="line">10</div></pre></td></tr></table></figure></p>
<p>改为let后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">for (let i = 0; i &lt; 10 ; i++) &#123;</div><div class="line">    setTimeout(function() &#123;console.log(i); &#125;, 100 * i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">0</div><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td></tr></table></figure></p>
<p>这个才是我们想要的结果，因此推荐在ts中或者es6中使用let来代替。</p>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><h3 id="let-声明"><a href="#let-声明" class="headerlink" title="let 声明"></a>let 声明</h3><p>通过上面的小例子可以看出<code>var</code>声明存在的问题，这也说明了用<code>let</code>声明变量的好处。除了名字不一样以外，let声明变量的写法与var是一样的。<br><code>let i: number = 0;</code><br>我们都知道，在js中，通过var声明的变量会有一个变量声明提前，即js解析引擎读取到var之后，会将var声明的变量提升至开始并赋值undefined，当用到的时候，才会再进行重新赋值。</p>
<h5 id="变量声明不提前"><a href="#变量声明不提前" class="headerlink" title="变量声明不提前"></a>变量声明不提前</h5><p>而使用let声明的变量，不会出现变量声明提前，所以如果在let声明之前使用let声明的变量会报错。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">a++; //变量a的作用域在let声明之后，所以此处找不到，报错。</div><div class="line">let a: number = 0;</div></pre></td></tr></table></figure></p>
<h5 id="let的作用域"><a href="#let的作用域" class="headerlink" title="let的作用域"></a>let的作用域</h5><p>如果是在函数中或者其他块级作用域如for、if等，用let声明的话，函数外面也是找不到的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function f(input: boolean) &#123;</div><div class="line">    let a = 100;</div><div class="line"></div><div class="line">    if (input) &#123;</div><div class="line">        // if语句块在变量a的作用域中，可以找到。</div><div class="line">        let b = a + 1;</div><div class="line">        return b;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 变量b的作用域为if语句块，所以此处找不到，报错。</div><div class="line">    return b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的例子中，我们通过let分别声明了两个变量a、b。<br>a的作用域是f函数体内，所以，在if语句中可以找到。<br>b的作用域是if语句块内，所以外部找不到就会报错。</p>
<h5 id="关于重复声明的问题"><a href="#关于重复声明的问题" class="headerlink" title="关于重复声明的问题"></a>关于重复声明的问题</h5><p>之前的js中，无论用var重复声明一个变量多少次，都不会报错，但是还是只有一个。如果重复声明并给同一个变量赋值的话，也不会报错，只是变量的值是最后一次赋值的值。<br>但是当我们通过let进行声明变量时，在同一个作用域内声明两个相同的变量就会报错。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var a: string = &apos;hi&apos;;</div><div class="line">var a: string = &apos;hehe&apos;; //不会报错，但是a的值为最后一次赋值的值，即为hehe;</div><div class="line"></div><div class="line"></div><div class="line">let b: number = 0;</div><div class="line">let b; //报错，相同作用域内不能使用let重复声明同一个变量。</div></pre></td></tr></table></figure></p>
<h3 id="const-声明"><a href="#const-声明" class="headerlink" title="const 声明"></a>const 声明</h3><p>const是声明常量，这个大家在js中应该也有用过。const的作用域与let相同，但是const声明的变量的值不会发生改变。<br>const还有一个好处就是，采用const声明的变量如果赋值的是一个表达式或者计算，在声明之初，这个值就已经计算出来了。不会像var一样，每次用到这个变量都会在计算一遍。在项目中遇到了很多绘制环形图或者折线图这种的需求，有很多变量是通过传入的数据或者图形来计算大小的，这个时候使用const，在声明之初就将这个变量的值计算了出来，后续的调用会提高效率。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function drawLine(length: number): void &#123;</div><div class="line">    //声明完就会将num的值计算出来。</div><div class="line">    const num: number = length * 10 + 1;</div><div class="line"></div><div class="line">    //num已经计算好了，直接调用，不会像var声明的变量一样每次调用都会重新计算。</div><div class="line">    console.log(num);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>const变量的内部状态是可以改变的，如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">const zhangshuang = &#123;</div><div class="line">    name: zhangshuang,</div><div class="line">    age: 26</div><div class="line">&#125;</div><div class="line"></div><div class="line">zhangshuang.name = ZhangShuang; //不会报错，内部状态修改了。</div></pre></td></tr></table></figure></p>
<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><h3 id="let-VS-const"><a href="#let-VS-const" class="headerlink" title="let  VS  const"></a>let  VS  const</h3><p>那么我们什么时候用let，什么时候使用const呢？一般来说，变量的声明最好遵循最小特权原则。也就是说，如果这个变量声明之后不会更改，那么我们就用const来声明；如果以后可能会改变，那我们就使用let来声明。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[TypeScript初试（一）]]></title>
      <url>http://zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>跟egret引擎一样，学习typescript也是因为公司的需求。虽然typescript算是JavaScript的超集，按理说应该跟js很像，但是个人感觉ts真的跟java更像一下。遇到有搞不懂的问题都是像公司后端及android童鞋们求助解决的，在这里先谢啦~<br>当然有一些像interface接口这种的，我的项目中没有用到，而且我问了几次也不是很理解，感觉不用这个也可以操作。<br>废话不多说了，下面就说一下我通过这个项目总结的一些经验：</p>
<a id="more"></a>
<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><p>ts跟js相比，语法上严禁了一些。js动态语言的特性当然也就没了，书写的时候一般都要跟上类型，如：<br><code>let isProto: boolean = false;</code><br>后面就不会对这种东东再进行赘述。<br>这里的 <code>: boolean</code> 就是对变量 <code>isProto</code> 类型的说明，每一种语言都会有相应的基本类型，这些网上都有很多，<br>例如：<a href="https://www.gitbook.com/book/zhongsp/typescript-handbook/details" target="_blank" rel="external">TypeScript Handbook</a>等，当时学习的时候就是从网上找的这种的一点一点看的。基本的语法在这里就简单一点带过。</p>
<h5 id="布尔值-boolean"><a href="#布尔值-boolean" class="headerlink" title="布尔值 boolean"></a>布尔值 boolean</h5><p>最基本的数据类型就是简单的true/false，这个就是布尔类型(boolean)<br><code>let isProto: boolean = false;</code></p>
<h5 id="数字类型-number"><a href="#数字类型-number" class="headerlink" title="数字类型 number"></a>数字类型 number</h5><p>ts中的number跟js一样也是浮点数，这个跟java什么的不太一样，没有int或者float整形或浮点型，只有一个number数字类型。这里有一点需要注意，如果想要通过二进制传输的话，js跟ts的number类型最多只支持15位数字，数字位数变多就会不精确。例如我的项目中，前后端数据传输就采用的protobuf这种二进制格式，在定义userID的时候用的long，并且是18位，结果在传输过来时发现末尾不是0的出现了些问题，变得跟原来不一样了。后来查阅各种资料才发现了这个问题，然后就将这种较长的数字也改为string类型替代了。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let i: number = 0;</div><div class="line">let colorRed = 0xff0000;</div></pre></td></tr></table></figure></p>
<h5 id="字符串-string"><a href="#字符串-string" class="headerlink" title="字符串 string"></a>字符串 string</h5><p>在ts中，string类型跟js中的一样，就不在多说了<br><code>let name: string = &#39;zhangshuang&#39;;</code><br><a href="https://www.gitbook.com/book/zhongsp/typescript-handbook/details" target="_blank" rel="external">TypeScript Handbook</a>中还介绍了模板字符串的用法，如果有需要也可以参考一下。当然我的项目中没有用到这个。</p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>TypeScript中，数组有两种表示方法：<br>1.元素类型后跟上[ ]<br><code>let numList: number[] = [1,2,3];</code><br>2.数组泛型<br><code>let numList: Array&lt;number&gt; = [1,2,3];</code></p>
<h5 id="枚举-enum"><a href="#枚举-enum" class="headerlink" title="枚举 enum"></a>枚举 enum</h5><p>最初我理解枚举的时候是将enum分成e+num，本质上还是数字，官方的解释就是将一系列数字赋予友好的名字，它的用法也很强大：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">enum fontColor = &#123;</div><div class="line">    gameRed = 0xff0099, //游戏中的红色</div><div class="line">    gameBlue = 0x0099ff //游戏中的蓝色</div><div class="line">&#125;</div><div class="line">let red: number = fontColor.gameRed;</div><div class="line"></div><div class="line"></div><div class="line">enum errorMsg = &#123;</div><div class="line">    &quot;网络连接故障，请耐心等待&quot; = 5000,</div><div class="line">    &quot;账号在其他位置登录，如不是本人请更改密码&quot; = 5001</div><div class="line">&#125;</div><div class="line">let eMsg: string = errorMsg[5000];</div></pre></td></tr></table></figure></p>
<p>可以说是结合了对象的<code>.</code>跟数组的[number]的用法于一身，具体怎么使用要看自己。比如第一种的fontColor，颜色数值0xff0099比较难记，如果使用<code>fontColor.gameRed</code>就可以解决这个问题；第二种errorMsg，错误提示较长，就可采用<code>errorMsg[5000]</code>来解决。</p>
<h5 id="任意值-any"><a href="#任意值-any" class="headerlink" title="任意值 any"></a>任意值 any</h5><p>ts中的任意值就是为了解决在编程时不清楚变量的类型而定义的一种类型，这个就相当于js的隐式类型转换。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">let notSure: any = 4;</div><div class="line">notSure = &apos;改变了类型&apos;;</div></pre></td></tr></table></figure></p>
<h5 id="空值-void"><a href="#空值-void" class="headerlink" title="空值 void"></a>空值 void</h5><p>我理解这个void是通过函数来理解的。有的函数有返回值，有的没有，为了代码清晰严谨，有返回值的函数就写返回值的类型，没有返回值的函数直接写void<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">//有返回值，类型为string</div><div class="line">function getName(name: string): string &#123;</div><div class="line">    return name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//没有返回值</div><div class="line">function alert(): void &#123;</div><div class="line">    alert(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="其他的类型"><a href="#其他的类型" class="headerlink" title="其他的类型"></a>其他的类型</h5><p>还有一些类型如元组Tuple，Never等因为在项目中没有用到，所以在这里也没再多说，如果有兴趣可以去<a href="https://www.gitbook.com/book/zhongsp/typescript-handbook/details" target="_blank" rel="external">TypeScript Handbook</a>中寻找一下。</p>
<p>下次分享一下变量声明var、let、const</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（七）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%83%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享几个封装的egret方法。<br>之前也调研过createjs，感觉egret的绘画API跟createjs的相似，或者说，这一类都是大同小异的。虽然这些方法相较原声的canvas简单一点，但是感觉还是有些繁杂，可以将这些方法封装一下进行调用。</p>
<ol>
<li>根据资源名称创建图片Bitmap<br>当我们新建一个egret项目的时候，就会在Main.ts中发现这个方法。这个方法直接传入一个在default.res.json中定义好的图片资源名称，就可以返回一个egret.Bitmap对象。其实这也就是在提示我们将文字、绘图等方法进行封装，使用起来会更加高效。<a id="more"></a>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function createBitmapByName(name: string): egret.Bitmap &#123;</div><div class="line">    const resource: egret.Bitmap = new egret.Bitmap();</div><div class="line">    const texture: egret.Texture = RES.getRes(name);</div><div class="line">    resource.texture = texture;</div><div class="line">    return resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>创建文本类TextFiled</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建文本类TextFiled</div><div class="line"> *</div><div class="line"> * @param &#123;string&#125; text 要显示的文字</div><div class="line"> * @param &#123;number&#125; color 文字的颜色</div><div class="line"> * @param &#123;number&#125; [size=20] 文字的大小</div><div class="line"> * @param &#123;number&#125; [x=0] 文字的x坐标</div><div class="line"> * @param &#123;number&#125; [y=0] 文字的y坐标</div><div class="line"> */</div><div class="line">function createText(text: string, color: number, size: number = 20, x: number = 0, y: number = 0): egret.TextFiled &#123;</div><div class="line">    const resource: egret.TextFiled = new egret.TextFiled();</div><div class="line">    resource.text = text;</div><div class="line">    resource.color = textColor;</div><div class="line">    resource.size = size;</div><div class="line">    resource.x = x;</div><div class="line">    resource.y = y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建带有矢量绘制功能的显示容器sprite<br>个人感觉这个方法使用的相当频繁，因为我是将sprite作为一个组件去使用的。打个比方来说，我要创建一张卡牌，那么我先创建一个sprite并将其添加到场景上，然后再创建一些卡牌的图案或者文字，添加到sprite上。每次要移动卡牌的时候，只需要操作sprite就好了，其内的文本类后者矢量绘图类都会随之移动。<br>值得一提的是，如果是创建一个类继承自egret.Sprite，并且这个类有点击等监听事件，如果无法触发，请设置其touchEnable属性变为true;如果有些地方触发有效果有些地方无效果，就要创建一个同等大小的shape，并且将其的alpha设置为0，放置在sprite上即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建带有矢量绘制功能的显示容器sprite</div><div class="line"> *</div><div class="line"> * @param &#123;number&#125; width 显示容器的宽</div><div class="line"> * @param &#123;number&#125; height 显示容器的高</div><div class="line"> * @param &#123;number&#125; [x=0] 显示容器的x坐标</div><div class="line"> * @param &#123;number&#125; [y=0] 显示容器的y坐标</div><div class="line"> * @returns &#123;egret.Sprite&#125; 返回显示容器对象</div><div class="line"> */</div><div class="line">function createSprite(width: number, height: number, x: number = 0, y: number = 0): egret.Sprite &#123;</div><div class="line">    const resource: egret.Sprite = new egret.Sprite();</div><div class="line">    resource.width = width;</div><div class="line">    resource.height = height;</div><div class="line">    resource.x = x;</div><div class="line">    resource.y = y;</div><div class="line">    return resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>创建矢量图Shape<br>我在最开始使用的时候，将x跟y直接用在drawRect中，但是通过egret wing自带的调试工具调试后发现，他的实际位置显示的有问题。所以现在在使用drawRect的时候，将x跟y都设置为0，再通过刚刚传入的x跟y坐标设置这个矢量图对象的位置。<br>这个只是创建矩形、还有很多如圆弧、圆形等可以参照这个自行封装。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line"> * 创建矢量图Shape</div><div class="line"> *</div><div class="line"> * @param &#123;number&#125; width 矢量图的宽</div><div class="line"> * @param &#123;number&#125; height 矢量图的高</div><div class="line"> * @param &#123;number&#125; color 矢量图的颜色</div><div class="line"> * @param &#123;number&#125; [x=0] 矢量图的x坐标</div><div class="line"> * @param &#123;number&#125; [y=0] 矢量图的y坐标</div><div class="line"> * @param &#123;number&#125; [alpha=1] 矢量图的透明度</div><div class="line"> * @returns &#123;egret.Shape&#125; 返回矢量图对象</div><div class="line"> */</div><div class="line">function createShape(width: number, height: number, color: number, x: number = 0, y: number = 0, alpha: number = 1): egret.Shape &#123;</div><div class="line">    const resource: egret.Shape = new egret.Shape();</div><div class="line">    resource.graphics.beginFill(color, alpha);</div><div class="line">    resource.graphics.drawRect(0, 0, width, height);</div><div class="line">    resource.graphics.endFill();</div><div class="line">    resource.x = x;</div><div class="line">    resource.y = y;</div><div class="line">    return resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>另附一个自己封装的环形图代码：<br>这个实现了传入一个sprite对象以及固定格式的数据，将环形图及图例添加到传入对象的特定方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/**</div><div class="line">     * 画饼图</div><div class="line">     * obj，在哪个对象上绘制</div><div class="line">     * data，饼图数据，格式固定</div><div class="line">     *</div><div class="line">     * @export</div><div class="line">     * @param &#123;any&#125; obj</div><div class="line">     * @param &#123;any&#125; data</div><div class="line">     */</div><div class="line">    export function drawCircle(obj, data) &#123;</div><div class="line">        const objWidth: number = obj.width;</div><div class="line">        const objHeight: number = obj.height;</div><div class="line">        const width: number = obj.width * 0.8; //新创建的背景的宽度,宽高相同</div><div class="line">        const height: number = obj.height * 0.8; //新创建的背景的高度</div><div class="line">        const lineHeight: number = 35;</div><div class="line">        const length: number = data.length; //数据长度</div><div class="line">        let startDeg = 0; //扇形起始角度</div><div class="line">        let endDeg = 0; //结束角度</div><div class="line"></div><div class="line">        let percentBg: egret.Sprite = new egret.Sprite();</div><div class="line">        percentBg.width = width;</div><div class="line">        percentBg.height = height;</div><div class="line">        percentBg.x = (objWidth - width) / 2;</div><div class="line">        percentBg.y = 95;</div><div class="line">        obj.addChild(percentBg);</div><div class="line">        let percentTotalBg: egret.Sprite = new egret.Sprite();</div><div class="line">        percentTotalBg.width = width;</div><div class="line">        let circleBg: egret.Sprite = new egret.Sprite();</div><div class="line">        percentTotalBg.addChild(circleBg);</div><div class="line">        circleBg.width = width;</div><div class="line">        circleBg.height = width;</div><div class="line">        circleBg.y = 0;</div><div class="line"></div><div class="line">        for (let i = 0; i &lt; length; i++) &#123; //环形图浅色部分</div><div class="line">            endDeg = (data[i].industryPercent).toFixed(2) * 3.6 + startDeg;</div><div class="line">            circleBg.graphics.beginFill(GameConfig.lightColor[i]);</div><div class="line">            circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">            circleBg.graphics.lineTo(width, width / 2);</div><div class="line">            circleBg.graphics.drawArc(width / 2, width / 2, width / 2.3, (startDeg + 2) * Math.PI / 180, endDeg * Math.PI / 180);</div><div class="line">            circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">            circleBg.graphics.endFill();</div><div class="line">            startDeg = endDeg;</div><div class="line">        &#125;</div><div class="line">        for (let i = 0; i &lt; length; i++) &#123; //环形图深色部分</div><div class="line">            endDeg = (data[i].industryPercent).toFixed(2) * 3.6 + startDeg;</div><div class="line">            circleBg.graphics.beginFill(GameConfig.darkColor[i]);</div><div class="line">            circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">            circleBg.graphics.lineTo(width, width / 2);</div><div class="line">            circleBg.graphics.drawArc(width / 2, width / 2, width / 2.6, (startDeg + 2) * Math.PI / 180, endDeg * Math.PI / 180);</div><div class="line">            circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">            circleBg.graphics.endFill();</div><div class="line">            startDeg = endDeg;</div><div class="line">        &#125;</div><div class="line">        circleBg.graphics.beginFill(GameConfig.TextColors.white); //环形图中间白色部分</div><div class="line">        circleBg.graphics.moveTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.lineTo(width, width / 2);</div><div class="line">        circleBg.graphics.drawArc(width / 2, width / 2, width / 3.5, 0, 360 * Math.PI / 180);</div><div class="line">        circleBg.graphics.lineTo(width / 2, width / 2);</div><div class="line">        circleBg.graphics.endFill();</div><div class="line"></div><div class="line">        let centerIcon = ZpyGameUtils.createBitmapByName(&quot;card_dark_icon_png&quot;); //中心icon</div><div class="line">        centerIcon.x = width / 2 - centerIcon.width / 2 * 0.6;</div><div class="line">        centerIcon.y = width / 2 - centerIcon.height / 2 * 0.6;</div><div class="line">        centerIcon.scaleX = 0.6;</div><div class="line">        centerIcon.scaleY = 0.6;</div><div class="line">        circleBg.addChild(centerIcon);</div><div class="line">        percentTotalBg.addChild(circleBg);</div><div class="line"></div><div class="line">        let labelBg: egret.Sprite = new egret.Sprite();</div><div class="line">        labelBg.width = width - 40;</div><div class="line">        labelBg.x = 20;</div><div class="line">        labelBg.y = width;</div><div class="line">        for (let i = 0, len = data.length; i &lt; len; i++) &#123;</div><div class="line">            let icon: egret.Shape = new egret.Shape();</div><div class="line">            icon.graphics.beginFill(GameConfig.darkColor[i]);</div><div class="line">            icon.graphics.drawRect(0, i * lineHeight, 20, 20);</div><div class="line">            icon.graphics.endFill();</div><div class="line">            labelBg.addChild(icon);</div><div class="line"></div><div class="line">            let label: egret.TextField = ZpyGameUtils.createText(data[i].industryName + &apos;  &apos; + (data[i].industryPercent).toFixed(2) + &apos;%&apos;, GameConfig.TextColors.black, 20);</div><div class="line">            label.x = 30;</div><div class="line">            label.y = lineHeight * i;</div><div class="line">            labelBg.addChild(label);</div><div class="line">        &#125;</div><div class="line">        percentTotalBg.addChild(labelBg);</div><div class="line">        percentTotalBg.height = width + length * lineHeight;</div><div class="line"></div><div class="line">        var scrollView: egret.ScrollView = new egret.ScrollView();</div><div class="line">        scrollView.setContent(percentTotalBg);</div><div class="line">        scrollView.width = width;</div><div class="line">        scrollView.height = height;</div><div class="line">        percentBg.addChild(scrollView);</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（六）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享一下通信控制SocketManager。<br>在egret引擎中，websocket是作为第三方库存在的，需要在创建之初将websocket选项选中，或者参照官网教程，在egret项目的egretProperties.json中编写。<a href="http://developer.egret.com/cn/github/egret-docs/extension/threes/instructions/index.html" target="_blank" rel="external">官网-如何使用第三方库</a></p>
<p>通信控制也是采用单例模式，里面也会有几个方法：<br><a id="more"></a></p>
<p>当socket连接打开<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.webSocket.addEventListener(egret.Event.CONNECT, this.onSocketOpen, this);</div></pre></td></tr></table></figure></p>
<p>当socket连接关闭，这个地方会有一些处理。如：掉线重连操作等<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.webSocket.addEventListener(egret.Event.CLOSE, this.onSocketClose, this);</div></pre></td></tr></table></figure></p>
<p>当socket连接错误<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.webSocket.addEventListener(egret.IOErrorEvent.IO_ERROR, this.onSocketError, this);</div></pre></td></tr></table></figure></p>
<p>当接收到后端传过来的消息，因为通信是通过protobuf，所以这个地方接收到消息后，会传入SocketDataHandler方法中按照cmd进行对应的解析，如果发送的消息很多的话，这里也要写很多。值得注意的是，书写的顺序必须与后端保持一致。这里我也没大有发言权，毕竟是另一个同事调研编写的。但是个人感觉通过protobuf相当麻烦，需要给每一条消息体都做相应的定义，加上处理数据需要写一遍、通过不同cmd执行不同方法写一遍，加起来就是要在收到消息这里编写三次。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.webSocket.addEventListener(egret.ProgressEvent.SOCKET_DATA, this.onReceiveMessage, this);</div></pre></td></tr></table></figure></p>
<p>通过url与后端进行连接<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.webSocket.connectByUrl(GlobalData.scUrl);</div></pre></td></tr></table></figure></p>
<p>在消息传输的过程中发现了一个语言层面的巨大无比的坑…<br>ts中使用protobuf时需要定义一个该条消息的类型，类似string、int32、int64这种的。之前在定义userID的时候，将类型写为int64，结果发现userID尾数不是0的都变为了0，好像是第15为之后。找了各种资料才发现，js只能到15位，最终无奈将userID这个类型变为了string。</p>
<hr>
<p>下次会分享几个封装的egret方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（五）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享一下场景切换类ViewManager。说起场景切换不得不说与其相配合的场景切换事件ChangeSceneEvent。</p>
<h4 id="场景切换事件：ChangeSceneEvent"><a href="#场景切换事件：ChangeSceneEvent" class="headerlink" title="场景切换事件：ChangeSceneEvent"></a>场景切换事件：ChangeSceneEvent</h4><p>该事件继承自egret.Event<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class ChangeSceneEvent extends egret.Event &#123;</div><div class="line">    public static CHANGE_SCENE_EVENT: string = &apos;changesceneevent&apos;;</div><div class="line">    public eventType: any; //事件类型</div><div class="line">    public obj: any; //对象</div><div class="line">    public constructor(type: string, bubbles: boolean = false, cancelable: boolean = false) &#123;</div><div class="line">        super(type, bubbles, cancelable);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>eventType是自定义的事件类型，即每个场景的类中的静态属性；<br>obj是指在哪个场景调用这个方法，然后将当前场景传过去，执行当前场景的end方法。<br>调用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private goNextView() &#123;</div><div class="line">    SoundManager.getInstance().playClick();</div><div class="line">    var changeEvent = new ChangeSceneEvent(ChangeSceneEvent.CHANGE_SCENE_EVENT);</div><div class="line">    changeEvent.eventType = PkGameGuideView.PK_GAME_GUIDE_VIEW;</div><div class="line">    changeEvent.obj = this;</div><div class="line">    ViewManager.getInstance().dispatchEvent(changeEvent);</div><div class="line">&#125;</div><div class="line"></div><div class="line">private end() &#123;</div><div class="line">    GameLayerManager.gameLayer().sceneLayer.removeChild(this);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在调用时，首先new一个ChangeSceneEvent事件，并传入事件名CHANGE_SCENE_EVENT，也就是之前事件类中的公共静态方法。然后将当前场景的静态属性（在这里是PkGameGuideView.PK_GAME_GUIDE_VIEW）作为eventType的值，这个会在场景控制ViewManager中调用。</p>
<h4 id="场景控制类：ViewManager"><a href="#场景控制类：ViewManager" class="headerlink" title="场景控制类：ViewManager"></a>场景控制类：ViewManager</h4><p>场景控制类只有一个作用，那就是根据场景切换事件传过来的要切换成哪个场景，执行对应的操作。<br>这个类同样也只会存在一个，所以也是采用单例模式来写。<br>首先在初始化的时候将游戏中的所有场景都声明一遍并赋值<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private firstGuideView: FirstGuideView;</div><div class="line">private gameMainView: GameMainView;</div><div class="line">private init() &#123;</div><div class="line">    this.gameMainView = GameMainView.getInstance();</div><div class="line">    this.firstGuideView = FirstGuideView.getInstance();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后不要忘了在初始化的同时，添加场景切换的事件监听<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.addEventListener(ChangeSceneEvent.CHANGE_SCENE_EVENT, this.onChangeScene, this);</div></pre></td></tr></table></figure></p>
<p>最后，在onChangeScene方法中，通过传入的eventType来执行相对应的操作。当然在onChangeScene方法中也会先调用obj.end()方法，执行原有场景类中的end方法。如果怕页面上有东西还可以调用一下sceneLayer的removeChildren()方法，删除场景层上的所有内容。<br>贴一下完整代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class ViewManager extends egret.Sprite &#123;</div><div class="line"></div><div class="line">    private static instance: ViewManager;</div><div class="line"></div><div class="line">    public constructor() &#123;</div><div class="line">        super();</div><div class="line">        this.init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static getInstance(): ViewManager &#123;</div><div class="line">        if(ViewManager.instance == null) &#123;</div><div class="line">            ViewManager.instance = new ViewManager();</div><div class="line">        &#125;</div><div class="line">        return ViewManager.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //声明各个页面</div><div class="line">    private firstGuideView: FirstGuideView; //第一次登陆页面</div><div class="line">    private chooseCardGuideView: ChooseCardGuideView; //选牌页面新手引导模块</div><div class="line">    private gameMainView: GameMainView; //游戏主页</div><div class="line">    private connectingView: ConnectingView; //匹配页面</div><div class="line">    //......</div><div class="line">    //有多少场景就写多少</div><div class="line"></div><div class="line">    public init() &#123;</div><div class="line">        this.gameMainView = GameMainView.getInstance();</div><div class="line">        this.firstGuideView = FirstGuideView.getInstance();</div><div class="line">        this.chooseCardGuideView = ChooseCardGuideView.getInstance();</div><div class="line">        this.connectingView = ConnectingView.getInstance();</div><div class="line">        //......</div><div class="line">        //有多少场景就写多少</div><div class="line">        this.addEventListener(ChangeSceneEvent.CHANGE_SCENE_EVENT, this.onChangeScene, this); //侦听场景改变事件</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private onChangeScene(e: ChangeSceneEvent) &#123;</div><div class="line">        e.obj.end();</div><div class="line">        GameLayerManager.gameLayer().sceneLayer.removeChildren();</div><div class="line"></div><div class="line">        switch (e.eventType) &#123;</div><div class="line">            case FirstGuideView.FIRST_GUIDE_VIEW: //新手引导页</div><div class="line">                GameLayerManager.gameLayer().sceneLayer.addChild(this.firstGuideView);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case GameMainView.GAME_MAIN_VIEW: //游戏主页面</div><div class="line">                GameLayerManager.gameLayer().sceneLayer.addChild(this.gameMainView);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case ConnectingView.CONNECTING_VIEW: //匹配页面</div><div class="line">                GameLayerManager.gameLayer().sceneLayer.addChild(this.connectingView);</div><div class="line">                break;</div><div class="line"></div><div class="line">            case ChooseCardGuideView.CHOOSE_CARD_GUIDE_VIEW: //选牌页面新手引导模块</div><div class="line">                GameLayerManager.gameLayer().sceneLayer.addChild(this.chooseCardGuideView);</div><div class="line">                break;</div><div class="line"></div><div class="line">            //......</div><div class="line">            //有多少场景就写多少</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>游戏的流程控制FlowManager以及配合使用的收到消息时间ReceiveMessageEvent写法跟用法跟本篇相似，就不在另行分享了。</p>
<hr>
<p>下次分享一下通信控制SocketManager。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（四）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享一下Controller中的场景管理类GameLayerManager。<br>同样采用单例模式，这个类中会使用eui创建多个图层，如：场景管理处SceneLayer，特效层EffectLayer等。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public sceneLayer: eui.UILayer = new eui.UILayer();</div><div class="line">public loadLayer: eui.UILayer = new eui.UILayer();</div><div class="line">public maskLayer: eui.UILayer = new eui.UILayer();</div><div class="line">public panelLayer: eui.UILayer = new eui.UILayer();</div><div class="line">public effectLayer: eui.UILayer = new eui.UILayer();</div></pre></td></tr></table></figure></p>
<p>当一个页面同时存在多个图层时，不可避免的就会出现有些图层不能点击的问题。这个时候就需要通过设置touchThrough这个属性，来允许可以透过当前图层点击到下一图层的内容。这里的点击到下一图层指的是空白区域，<br><a id="more"></a></p>
<p>如：<br><img src="https://ooo.0o0.ooo/2017/01/18/587f60a6d1c67.png" alt="touchThrough图例"><br>如果上图的黑色透明部分没有颜色，即没有在黑色透明位置添加东西，那么下面的那张卡牌是可以点击的。但是需求是不能点击，所以给这里添加了黑色透明mask。</p>
<p>跟css中的z-index类似，图层也有个放置的顺序问题。在egret引擎中，后添加的层级要高于早添加的。也就是在本游戏中panelLayer弹窗层处于最上面，所以panelLayer要最后添加。因为游戏弹窗总是在场景的上方，所以要先添加sceneLayer，后添加panelLayer。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">this.addChild(this.sceneLayer);</div><div class="line">this.addChild(this.panelLayer);</div></pre></td></tr></table></figure></p>
<p>这个类内容比较少，同样贴一下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class GameLayerManager extends eui.UILayer &#123;</div><div class="line"></div><div class="line">    private static instance: GameLayerManager;</div><div class="line">    public constructor() &#123;</div><div class="line">        super();</div><div class="line">        this.init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static gameLayer(): GameLayerManager &#123;</div><div class="line">        if (!this.instance) &#123;</div><div class="line">            this.instance = new GameLayerManager();</div><div class="line">        &#125;</div><div class="line">        return this.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //创建场景图层</div><div class="line">    public sceneLayer: eui.UILayer = new eui.UILayer(); //场景层，如各个页面</div><div class="line">    public loadLayer: eui.UILayer = new eui.UILayer(); //加载遮罩层    </div><div class="line">    public maskLayer: eui.UILayer = new eui.UILayer(); //遮罩层</div><div class="line">    public panelLayer: eui.UILayer = new eui.UILayer(); //弹窗层，如签到，设置等</div><div class="line">    public effectLayer: eui.UILayer = new eui.UILayer(); //特效层，如倒计时等</div><div class="line"></div><div class="line">    private init() &#123;</div><div class="line">        this.touchThrough = true;</div><div class="line">        this.loadLayer.touchThrough = true;</div><div class="line">        this.sceneLayer.touchThrough = true;        </div><div class="line">        this.maskLayer.touchThrough = true;</div><div class="line">        this.effectLayer.touchThrough = true;        </div><div class="line">        this.panelLayer.touchThrough = true;</div><div class="line"></div><div class="line">        this.addChild(this.sceneLayer);</div><div class="line">        this.addChild(this.loadLayer);</div><div class="line">        this.addChild(this.maskLayer);</div><div class="line">        this.addChild(this.effectLayer);</div><div class="line">        this.addChild(this.panelLayer);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>下次会分享一下场景切换类ViewManager。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（三）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享一下Controller中的SoundManager声音控制。<br>在游戏需求评审的时候，发现游戏原型图中控制声音的只有一个按钮，也就是背景音乐的播放以及音效的播放时统一控制的，跟常见的游戏有音效开关、声音开关以及音量大小调节完全不同。但是总感觉这里有坑，暂且分开开发，然后关联到一起。这样以后有多个按钮的需求时微微动下代码就能使用。<br><a id="more"></a></p>
<p>这里注意一下，egret引擎对音频资源比较挑剔，只能使用MP3格式的音频文件，如果播放不出来的话可以参照官网对于音频文件的说明，可以使用格式工厂进行码率转变。<a href="http://developer.egret.com/cn/github/egret-docs/Engine2D/multimedia/audio/index.html" target="_blank" rel="external">egret官网-音频说明</a><br>经过多个demo的迭代以及请教公司的后端，像控制器或者场景这种同时只能存在一个的这种Class，我都做成了单例模式。也就是每次都会调用getInstance方法来找到这个Class的实例。</p>
<p>首先是声明一个静态的私有属性，这个属性跟类名相同。即：private static instance: SoundManager;<br>其次是声明一个公共的静态方法，getInstance()。即：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">public static getInstance(): SoundManager &#123;</div><div class="line">    if(SoundManager.instance == null) &#123;</div><div class="line">        SoundManager.instance = new SoundManager();</div><div class="line">    &#125;</div><div class="line">    return SoundManager.instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法通过判断SoundManager.instance这个属性时候为null，如果是null则实例化一个SoundManager，如果不为null直接返回该属性，从而返回当前类的实例。</p>
<p>web端不像app端，将音乐设置没后再次打开也没有音乐。为了模拟这个效果，只能将音乐是否播放存入浏览器的localStorage中：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">egret.localStorage.setItem(&apos;ismusic&apos;,&apos;0&apos;);</div><div class="line">egret.localStorage.getItem(&apos;ismusic&apos;);</div></pre></td></tr></table></figure></p>
<p>这里的操作方法跟正常写页面的操作方法一样，设置就传入参数名（key）及参数值（value）；获取就传入参数名（key）就可调用。</p>
<p>音乐的播放时调用play方法，传入两个参数startTime开始时间，loops循环次数（0为无限循环）<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private bg: egret.Sound; //游戏背景音乐</div><div class="line"></div><div class="line">private init() &#123;</div><div class="line">    this.bg = new egret.Sound(); //游戏背景音乐</div><div class="line">    this.bg = RES.getRes(&apos;zpy_game_bg_mp3&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">public playSoundBg() &#123; //播放背景音乐</div><div class="line">    if(this.IsMusic) &#123;</div><div class="line">        this.bgChannel = this.bg.play(0, 0);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我这里没有写音量的控制，这里也说一下音量的问题：<br>首先要声明一个egret.SoundChannel类型的变量，该变量有个volume属性，当这个属性的值介于0-1之间。当属性值等于0时，音量最小，反之最大。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">private bgChannel: egret.SoundChannel; //用来静音</div><div class="line">public playSoundBg() &#123; //播放背景音乐</div><div class="line">    if(this.IsMusic) &#123;</div><div class="line">        this.bgChannel = this.bg.play(0, 0);</div><div class="line">        this.bgChannel.volume = 0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>贴一下这个类的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class SoundManager &#123;</div><div class="line"></div><div class="line">    private static instance: SoundManager;    </div><div class="line">    public constructor() &#123;</div><div class="line">        this.init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static getInstance(): SoundManager &#123;</div><div class="line">        if(SoundManager.instance == null) &#123;</div><div class="line">            SoundManager.instance = new SoundManager();</div><div class="line">        &#125;</div><div class="line">        return SoundManager.instance;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //不同的音效</div><div class="line">    private bg: egret.Sound; //游戏背景音乐</div><div class="line">    private click: egret.Sound; //点击音效</div><div class="line">    private getMoney: egret.Sound; //获得金币</div><div class="line">    private banker: egret.Sound; //成为庄家</div><div class="line">    private bgChannel: egret.SoundChannel; //用来静音</div><div class="line"></div><div class="line">    //在SoundManager初始化时将这些音效赋值为相应的预加载的游戏音频资源。</div><div class="line">    private init() &#123;</div><div class="line">        this.bg = new egret.Sound(); //游戏背景音乐</div><div class="line">        this.bg = RES.getRes(&apos;zpy_game_bg_mp3&apos;);</div><div class="line"></div><div class="line">        this.click = new egret.Sound(); //点击音效</div><div class="line">        this.click = RES.getRes(&apos;zpy_game_click_mp3&apos;);</div><div class="line"></div><div class="line">        this.getMoney = new egret.Sound(); //获得金钱</div><div class="line">        this.getMoney = RES.getRes(&apos;zpy_game_getMoney_mp3&apos;);</div><div class="line"></div><div class="line">        this.banker = new egret.Sound(); //成为庄家</div><div class="line">        this.banker = RES.getRes(&apos;zpy_game_banker_mp3&apos;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //音乐是否播放，保存设置</div><div class="line">    public set IsMusic(value) &#123;</div><div class="line">        if(!value) &#123;</div><div class="line">            egret.localStorage.setItem(&apos;ismusic&apos;,&apos;0&apos;);</div><div class="line">            this.stopSoundBg();</div><div class="line">        &#125;else &#123;</div><div class="line">            egret.localStorage.setItem(&apos;ismusic&apos;,&apos;1&apos;);</div><div class="line">            this.playSoundBg();            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public get IsMusic(): boolean &#123;</div><div class="line">        var b = egret.localStorage.getItem(&apos;ismusic&apos;);</div><div class="line">        if(b == null || b == &apos;&apos;) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;else &#123;</div><div class="line">            return b == &apos;1&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    //音效是否播放，保存设置，游戏一期对于声音只有一个控制按钮，所以在声音的模块中，停止背景音乐的同时，也将音效的声音关闭</div><div class="line">    public set IsSound(value) &#123;</div><div class="line">        if(!value) &#123;</div><div class="line">            egret.localStorage.setItem(&apos;issound&apos;,&apos;0&apos;);</div><div class="line">        &#125;else &#123;</div><div class="line">            egret.localStorage.setItem(&apos;issound&apos;,&apos;1&apos;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public get IsSound(): boolean &#123;</div><div class="line">        var b = egret.localStorage.getItem(&apos;issound&apos;);</div><div class="line">        if(b == null || b == &apos;&apos;) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;else &#123;</div><div class="line">            return b == &apos;1&apos;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public playSoundBg() &#123; //播放背景音乐</div><div class="line">        if(this.IsMusic) &#123;</div><div class="line">            this.bgChannel = this.bg.play(0, 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    public stopSoundBg() &#123; //停止背景音乐</div><div class="line">        if(this.bgChannel != null) &#123;</div><div class="line">            this.bgChannel.stop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public playClick() &#123; //点击音效</div><div class="line">        if(this.IsSound) &#123;</div><div class="line">            this.click.play(0,1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public playBanker() &#123; //成为庄家音效</div><div class="line">        if(this.IsSound) &#123;</div><div class="line">            this.banker.play(0,1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public playGetMoney() &#123;</div><div class="line">        if(this.IsSound) &#123;</div><div class="line">            this.getMoney.play(0,1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>下次分享一下场景层管理类GameLayerManager。</p>
<h6 id="2017年3月27日新增"><a href="#2017年3月27日新增" class="headerlink" title="2017年3月27日新增"></a>2017年3月27日新增</h6><p>预加载、自动播放无效<br><img src="https://ooo.0o0.ooo/2017/03/27/58d870b73f020.png" alt="预加载、自动播放无效"><br>如上表所示，经过简单的测试发现：预加载、自动播放的有效性受操作系统、浏览器、版本等影响，苹果官方规定必须由用户手动触发才会载入音频。即：用户手动随意点击任意位置即可播放音频。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（二）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>今天分享一下游戏入口类的编写。<br>首先游戏中默认的入口为Main.ts，但是因为是游戏入口，我只想在这里看到游戏加载后进入哪个页面，不想看见乱七八糟的游戏加载等事件。所以在这里将游戏入口拆分成两个部分，一个是入口的基类BaseMain，一个是入口类Main。这个地方是借鉴的别人的思想。</p>
<h2 id="游戏入口基类：BaseMain"><a href="#游戏入口基类：BaseMain" class="headerlink" title="游戏入口基类：BaseMain"></a>游戏入口基类：BaseMain</h2><a id="more"></a>
<p>先说一下基类吧，对于像我这样的不是计算机专业的，也没学过java这种语言的人来说，可能不知道什么是基类。百度的解释是：通过继承机制，可以利用已有的数据类型来定义新的数据类型。在本游戏中，游戏入口基类最要承担游戏资源的加载、egret自带的素材解析、egret自带的主题解析、以及加载完资源后的操作。</p>
<h6 id="资源加载RES"><a href="#资源加载RES" class="headerlink" title="资源加载RES"></a>资源加载RES</h6><p>游戏资源加载的作用是在游戏开始时预加载资源<br>其实egret自动生成的demo对这方面的解释也比较清晰，从每一个方法名来看就可以看出，这个方法的作用。<br>RES.ResourceEvent.CONFIG_COMPLETE是资源配置文件加载完成；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE,this.onConfigComplete,this);</div></pre></td></tr></table></figure></p>
<p>RES.ResourceEvent.GROUP_COMPLETE是资源组加载完成，之前调研的createjs也有类似的资源组。这里需要判断加载完什么资源之后要执行的方法。比如我在这里就有当loading资源组加载完成后，加载preload资源组，并且显示loading页面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE,this.onResourceLoadComplete,this);</div></pre></td></tr></table></figure></p>
<p>RES.ResourceEvent.GROUP_PROGRESS是资源组加载中，这里一般会做一个判断，如果不是loading资源组，就显示loading页面，并且显示所有游戏资源的加载情况（进度条）；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS,this.onResourceProgress,this);</div></pre></td></tr></table></figure></p>
<p>RES.ResourceEvent.GROUP_LOAD_ERROR是资源组加载出错；<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR,this.onResourceLoadError,this);</div></pre></td></tr></table></figure></p>
<p>RES.ResourceEvent.ITEM_LOAD_ERROR是某个资源加载出错。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR,this.onItemLoadError,this);</div></pre></td></tr></table></figure></p>
<p>RES.loadGroup(groupname)是开始加载某个资源组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">RES.loadGroup(&quot;loading&quot;);</div></pre></td></tr></table></figure></p>
<p>这里的private是这个类的私有属性方法，外部无法调用。就像<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function _alert()&#123;</div><div class="line">    alert(1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为js中没有私有、公共这个概念，有时候就会使用” _ “来约定，该属性或方法是私有的，外部不要调用。有addEventListener就有removeEventListener，也就是移除事件监听。因为游戏对性能要求比较高，不用了的监听需要及时移除，省的监听多了造成游戏卡顿。<br>之前也看到过单独编写资源加载类的，但是自己看了下，没有采用。</p>
<h6 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h6><p>如打开socket连接、发送第一条请求数据、注入egret定义的素材解析器、添加游戏图层（GameLayerManager）等都会在游戏的基类中编写。<br>最终贴一下BaseMain的代码吧，因为也是从头开始接触这个，所以注释什么的写的也比较全面。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">namespace base &#123;</div><div class="line"></div><div class="line">    export class BaseMain extends eui.UILayer &#123;</div><div class="line">        private loadingView: LoadingView; //加载页面</div><div class="line"></div><div class="line">        public constructor() &#123;</div><div class="line">            super();</div><div class="line">            this.addEventListener(egret.Event.ADDED_TO_STAGE, this._onAddToStage, this);</div><div class="line">        &#125;</div><div class="line">        private _onAddToStage() &#123;</div><div class="line">            SocketManager.getInstance().connection(); //开始websocket连接</div><div class="line"></div><div class="line">            this.stage.registerImplementation(&apos;eui.IAssetAdapter&apos;,new AssetAdapter()); //注入自定义的素材解析器</div><div class="line">            var theme = new eui.Theme(&apos;resource/default.thm.json&apos;, this.stage);</div><div class="line"></div><div class="line">            this.addChild(GameLayerManager.gameLayer()); //添加游戏图层</div><div class="line"></div><div class="line">            RES.addEventListener(RES.ResourceEvent.CONFIG_COMPLETE,this.onConfigComplete,this); //加载资源配置文件</div><div class="line">            RES.loadConfig(&apos;resource/default.res.json&apos;, &apos;resource/&apos;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private onConfigComplete(event: RES.ResourceEvent): void &#123;</div><div class="line">            RES.removeEventListener(RES.ResourceEvent.CONFIG_COMPLETE,this.onConfigComplete,this); //移除监听事件            </div><div class="line">            //代表什么时候加载资源,完成、预加载等</div><div class="line">            RES.addEventListener(RES.ResourceEvent.GROUP_COMPLETE,this.onResourceLoadComplete,this); //加载完成            </div><div class="line">            RES.addEventListener(RES.ResourceEvent.GROUP_PROGRESS,this.onResourceProgress,this); //加载进行中</div><div class="line">            RES.addEventListener(RES.ResourceEvent.GROUP_LOAD_ERROR,this.onResourceLoadError,this); //加载组错误</div><div class="line">            RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR,this.onItemLoadError,this); //加载单个文件错误</div><div class="line">            RES.loadGroup(&quot;loading&quot;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private onResourceProgress(event: RES.ResourceEvent): void &#123;</div><div class="line">            if(event.groupName != &apos;loading&apos;) &#123; //如果不是加载loading页面则显示进度条</div><div class="line">                this.loadingView.createLoadingBar(event.itemsLoaded, event.itemsTotal);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private onResourceLoadError(event: RES.ResourceEvent): void &#123;</div><div class="line">            console.error(&apos;资源[&apos; + event.groupName + &apos;]:加载失败&apos;);</div><div class="line">            this.onResourceLoadComplete(event);            </div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private onItemLoadError(event: RES.ResourceEvent): void &#123;</div><div class="line">            console.error(&apos;Url:&apos; + event.resItem.url + &apos;加载失败&apos;);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        private onResourceLoadComplete(event: RES.ResourceEvent): void &#123;</div><div class="line">            console.warn(&apos;资源[&apos; + event.groupName + &apos;]:加载完成&apos;);</div><div class="line">            this.addChild(ViewManager.getInstance()); //添加场景切换控制</div><div class="line"></div><div class="line">            if(event.groupName == &apos;loading&apos;) &#123; //如果加载完成的是loading资源组</div><div class="line">                this.loadingView = new LoadingView();</div><div class="line">                GameLayerManager.gameLayer().loadLayer.addChild(this.loadingView);</div><div class="line">                RES.loadGroup(&apos;preload&apos;);</div><div class="line">            &#125;else if(event.groupName == &apos;preload&apos;) &#123; //如果加载完成的是preload资源组</div><div class="line">                SoundManager.getInstance(); //预先加载声音，放到声音预加载之后再执行</div><div class="line">                if(GamePlayer.playerInfo.isNew) &#123; //判断是否是新用户</div><div class="line">                    RES.loadGroup(&apos;guide&apos;);</div><div class="line">                &#125;else &#123;</div><div class="line">                    let timer = setInterval(() =&gt; &#123;</div><div class="line">                        if(SocketManager.getInstance().isConnection) &#123;</div><div class="line">                            clearInterval(timer);</div><div class="line">                            this.start();</div><div class="line">                            GameLayerManager.gameLayer().loadLayer.removeChild(this.loadingView);                            </div><div class="line">                        &#125;                 </div><div class="line">                    &#125;,100)</div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;else if(event.groupName == &apos;guide&apos;) &#123; //如果是新用户 加载guide资源组</div><div class="line">                if(SocketManager.getInstance().isConnection &amp;&amp; GamePlayer.playerInfo.isNew) &#123;</div><div class="line">                    this.firstStart();</div><div class="line">                    GameLayerManager.gameLayer().loadLayer.removeChild(this.loadingView);</div><div class="line">                &#125;else if(SocketManager.getInstance().isConnection) &#123;</div><div class="line">                    GameLayerManager.gameLayer().loadLayer.removeChild(this.loadingView);                    </div><div class="line">                    this.start();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            let timer = setInterval(() =&gt; &#123;</div><div class="line">                if(SocketManager.getInstance().isConnection) &#123;</div><div class="line">                    clearInterval(timer);</div><div class="line">                    SocketManager.getInstance().sendData(GlobalData.Cmd.gameEnter);</div><div class="line">                &#125;</div><div class="line">            &#125;,100);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        public start(): void &#123;&#125; //走main.ts</div><div class="line">        public firstStart(): void &#123;&#125; //走main.ts</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    class AssetAdapter implements eui.IAssetAdapter &#123;</div><div class="line">        /**</div><div class="line">         * 解析素材</div><div class="line">         * @param source 待解析的新素材标识符</div><div class="line">         * @param compFunc 解析完成回调函数，示例：callBack(content:any,source:string):void;</div><div class="line">         * @param thisObject callBack的 this 引用</div><div class="line">         */</div><div class="line">        public getAsset(source: string, compFunc:Function, thisObject: any): void &#123;</div><div class="line">            function onGetRes(data: any): void &#123;</div><div class="line">                compFunc.call(thisObject, data, source);</div><div class="line">            &#125;</div><div class="line">            if (RES.hasRes(source)) &#123;</div><div class="line">                let data = RES.getRes(source);</div><div class="line">                if (data) &#123;</div><div class="line">                    onGetRes(data);</div><div class="line">                &#125;</div><div class="line">                else &#123;</div><div class="line">                    RES.getResAsync(source, onGetRes, this);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            else &#123;</div><div class="line">                RES.getResByUrl(source, onGetRes, this, RES.ResourceItem.TYPE_IMAGE);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    class ThemeAdapter implements eui.IThemeAdapter &#123;</div><div class="line">        /**</div><div class="line">         * 解析主题</div><div class="line">         * @param url 待解析的主题url</div><div class="line">         * @param compFunc 解析完成回调函数，示例：compFunc(e:egret.Event):void;</div><div class="line">         * @param errorFunc 解析失败回调函数，示例：errorFunc():void;</div><div class="line">         * @param thisObject 回调的this引用</div><div class="line">         */</div><div class="line">        public getTheme(url:string,compFunc:Function,errorFunc:Function,thisObject:any):void &#123;</div><div class="line">            function onGetRes(e:string):void &#123;</div><div class="line">                compFunc.call(thisObject, e);</div><div class="line">            &#125;</div><div class="line">            function onError(e:RES.ResourceEvent):void &#123;</div><div class="line">                if(e.resItem.url == url) &#123;</div><div class="line">                    RES.removeEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);</div><div class="line">                    errorFunc.call(thisObject);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            RES.addEventListener(RES.ResourceEvent.ITEM_LOAD_ERROR, onError, null);</div><div class="line">            RES.getResByUrl(url, onGetRes, this, RES.ResourceItem.TYPE_TEXT);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="入口类：Main"><a href="#入口类：Main" class="headerlink" title="入口类：Main"></a>入口类：Main</h2><p>游戏入口类继承自BaseMain。<br>刚刚的游戏入口类中，在preload资源组以及guide资源组加载完成之后，分别调用start跟firstStart方法。但是在基类中，这两个方法没有方法体。那么如何调用呢？<br>在入口类Main中，有两个公共方法，一个是start方法，一个是firstStart方法。因为这个类是继承自BaseMain的，所以在游戏一开始运行时会先执行基类的方法，等到资源加载完成要调用相应的start跟firstStart方法时，就会先调用当前入口类Main中的方法。如果Main中没有该方法，就会执行基类也就是BaseMain中的方法。<br>这个没有什么好说的，直接贴一下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">class Main extends base.BaseMain &#123;</div><div class="line"></div><div class="line">    public constructor() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public firstStart(): void &#123; //新玩家</div><div class="line">        var changeEvent = new ChangeSceneEvent(ChangeSceneEvent.CHANGE_SCENE_EVENT);</div><div class="line">        changeEvent.eventType = FirstGuideView.FIRST_GUIDE_VIEW;</div><div class="line">        changeEvent.obj = this;</div><div class="line">        ViewManager.getInstance().dispatchEvent(changeEvent);</div><div class="line">        SoundManager.getInstance().playSoundBg(); //播放背景音乐</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public start(): void &#123; //老玩家</div><div class="line">        var changeEvent = new ChangeSceneEvent(ChangeSceneEvent.CHANGE_SCENE_EVENT);</div><div class="line">        changeEvent.eventType = GameMainView.GAME_MAIN_VIEW;</div><div class="line">        changeEvent.obj = this;</div><div class="line">        ViewManager.getInstance().dispatchEvent(changeEvent);</div><div class="line">        SoundManager.getInstance().playSoundBg(); //播放背景音乐</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    private end(): void &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>下次会分享一下关于声音控制的方法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[egret游戏引擎入门（一）]]></title>
      <url>http://zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>最初调研egret其实也是迫不得已。因为当时公司突然有了做游戏的需求，然而全公司上下竟然没有一个有开发游戏的经验。然后需求被boss接下来之后分配给了我，然后说可以看一下createjs。<br>经过一个月的调研+demo制作之后发现，英文的API也能凑合看一看，但是大部分功能还是自己各种尝试。但是因为社区活跃度太低了，加了还几个群，网上各种找资料，没弄懂的依旧没弄懂。打个比方来说屏幕的适配问题，搞了三四天依旧没有搞定。<br>在这期间，闲着没事儿的时候就会看网上各种关于web游戏引擎的评价、对比。最终选定egret还是因为觉得egret有一整套的工具。比如：ResDepot可以可视化管理游戏资源的，Texture Merger将小图合成大图，ios/android-support等等。<br><a id="more"></a></p>
<p>在正式开发之前，也看过好多好多教程、代码，自己写的demo也从最开始的流水式函数式从上到下垒代码，到第五遍demo的时候变成了个人认为比较符合MVC设计结构的代码。<br>写这一系列文章也是想让那些没有游戏开发经验，但是有这个需求的小白前端开发者们快速的趟过我走过的那些坑。至于egret的API官网上都有，可以直接参照。当然在游戏开发方面我也是小白，这些都是自己看过好多代码好多教程总结出来的，如有问题希望各位大大们多多指教。</p>
<h4 id="游戏的框架："><a href="#游戏的框架：" class="headerlink" title="游戏的框架："></a>游戏的框架：</h4><p><img src="https://ooo.0o0.ooo/2017/01/18/587f2f4330877.png" alt="game_MVC"></p>
<h4 id="Model："><a href="#Model：" class="headerlink" title="Model："></a>Model：</h4><p>先说一下Model吧，游戏所有的数据包括新手引导的数据、游戏的设置、客户端维护的玩家对象、pk赛游戏中客户端维护的其他玩家对象组以及后端返回数据的操作都会作为Model部分。每一个都有对应的Class或者namespace(module)。</p>
<h4 id="View："><a href="#View：" class="headerlink" title="View："></a>View：</h4><p>因为采用了egret的eui，所以这里的View像ps中的一个一个的图层那样。每一层都会显示不同的内容。比如：场景层SceneLayer，游戏内的各个场景会放置在这一层中进行展示，这一层也是最为重要的一层；弹窗层PanelLayer，一个游戏肯定会有很多类似弹窗、弹框这种的提示信息或模块，这个时候就需要将这些东西放置到弹窗层中进行统一控制；遮罩层MaskLayer及效果层EffectLayer是用来存放遮罩及游戏动效的；加载层LoadLayer只有在游戏最开始加载的时候会用到，进入游戏大厅之后就会销毁。当然也可以当做场景放置在SceneLayer中。</p>
<h4 id="Controller："><a href="#Controller：" class="headerlink" title="Controller："></a>Controller：</h4><p>最后再说一下Controller。本游戏主要通过声音、通信、图层、流程、场景等几个纬度来进行Controller的设计的。声音控制SoundManager，用于游戏内声音、音效的控制；通信控制SocketManager以及附属的HandleSocket(用于解析protobuf的)来控制游戏的连接以及数据传输的解析；图层控制GameLayerManager，用于控制游戏的各个图层的层级关系，如PanelLayer高于SceneLayer，也可以理解为脱离文档留之后的z-index；场景控制ViewManager，用于控制游戏场景之间的切换；流程控制FlowManager，用在接收后端信息后执行对应的操作。</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>最后：egret引擎是采用typescript开发的，在调研egret的同时，顺便也学习了一下typescript。所以感觉这个游戏学习上手成本很高，但是也多会了一些平常写页面接触不到的。关于typescript的内容我会令外整理，本教程只分享egret引擎相关的内容。<br>因为是网络游戏，考虑到信息传输的速度问题，后端决定采用谷歌的二进制传输协议protobuf。protobuf是另外一个前端同事调研的，对于这块儿我也不是很了解，但是这里面会有很多坑，而且调试起来非常的不方便。其实感觉用json也可以，哈哈。</p>
<hr>
<p>下次会分享关于游戏入口类的编写。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodejs定时抓取服务器文件并生成页面]]></title>
      <url>http://zhangshuang.top/nodejs%E5%AE%9A%E6%97%B6%E6%8A%93%E5%8F%96%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%96%87%E4%BB%B6%E5%B9%B6%E7%94%9F%E6%88%90%E9%A1%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<p>最初觉得公司前端做的非产品提的需求的demo没有很好的利用起来，于是想能不能将前端组服务器中的所有demo自动抓取出来，并放置到一个页面中。这样一是有利于前端demo管理，二是其他部门用的时候找起来也比较方便。</p>
<h4 id="遍历文件夹"><a href="#遍历文件夹" class="headerlink" title="遍历文件夹"></a>遍历文件夹</h4><p>首先就是要遍历文件夹，获取所有文件夹里面的文件信息<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function geFileList(path) &#123;</div><div class="line">    var filesList = [];</div><div class="line">    readFile(path,filesList);</div><div class="line">    return filesList;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="遍历读取文件"><a href="#遍历读取文件" class="headerlink" title="遍历读取文件"></a>遍历读取文件</h4><a id="more"></a>
<p>然后就需要将第一步中获取的文件信息读取出来<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function readFile(path, filesList) &#123;</div><div class="line">    files = fs.readdirSync(path);//需要用到同步读取</div><div class="line">    files.forEach(walk);</div><div class="line">    function walk(file)</div><div class="line">    &#123;</div><div class="line">        states = fs.statSync(path+&apos;/&apos;+file);</div><div class="line">        if(states.isDirectory())</div><div class="line">        &#123;</div><div class="line">            readFile(path+&apos;/&apos;+file,filesList);</div><div class="line">        &#125;</div><div class="line">        else</div><div class="line">        &#123;</div><div class="line">            //创建一个对象保存信息</div><div class="line">            var obj = new Object();</div><div class="line">            obj.size = states.size;//文件大小，以字节为单位</div><div class="line">            obj.name = file;//文件名</div><div class="line">            obj.path = path+&apos;/&apos;+file; //文件绝对路径</div><div class="line">            filesList.push(obj);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>生成的filesList为一个包含服务器下所有文件的数组，其中数组中的每一个元素都是一个对象，包含<code>name、size、path</code>属性。</p>
<h4 id="匹配特定文件并生成包含title跟path的数组"><a href="#匹配特定文件并生成包含title跟path的数组" class="headerlink" title="匹配特定文件并生成包含title跟path的数组"></a>匹配特定文件并生成包含title跟path的数组</h4><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var arr = [],str = &apos;&apos;;</div><div class="line">var regTitle = /&lt;title&gt;(.*?)&lt;\/title&gt;/i; //匹配文件的title</div><div class="line">for(var i=0,len=filesList.length;i&lt;len;i++)&#123;</div><div class="line">    var item = filesList[i];</div><div class="line">    if(item.name.indexOf(&quot;index.html&quot;) != -1)&#123; //如果包含index.html</div><div class="line">        var data = fs.readFileSync(item.path);</div><div class="line">        var title = &apos;&quot;&apos;+regTitle.exec(data)[1] +&apos;&quot;&apos;;</div><div class="line">        arr.push(title);</div><div class="line">        var url = &apos;&quot;www.zhangshuang.top/project&apos; + item.path.slice(2) +&apos;&quot;&apos;;</div><div class="line">        arr.push(url);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">str = &apos;arr = [&apos;+arr+&apos;]&apos;;</div></pre></td></tr></table></figure>
<h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><p>将内容用utf-8的格式写入文件，后续会有调用<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function writeFile(fileName,data) &#123;</div><div class="line">    fs.writeFile(fileName,data,&apos;utf-8&apos;,complete);</div><div class="line">    function complete() &#123;</div><div class="line">        console.log(&quot;文件生成成功&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">writeFile(&quot;selfMotion_data.js&quot;,str); //第一个为自定义的生成的文件名，第二个为写入的数据</div></pre></td></tr></table></figure></p>
<h4 id="定时任务脚本"><a href="#定时任务脚本" class="headerlink" title="定时任务脚本"></a>定时任务脚本</h4><p>定时任务要感谢公司运维的小伙伴，之前在网上找了很多试了就是不行，结果是因为没有加执行的路径，现将shell脚本也贴出来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">/*bianli.sh*/</div><div class="line"></div><div class="line">#!/bin/bash</div><div class="line">cd /opt/node_server/public/project</div><div class="line">/usr/bin/node /opt/node_server/public/project/bianli.js</div></pre></td></tr></table></figure></p>
<p>记得一开始的cd进入项目目录一定要加上，要不然就不会执行。</p>
<h4 id="启动定时任务"><a href="#启动定时任务" class="headerlink" title="启动定时任务"></a>启动定时任务</h4><p>通过<code>vim /etc/crontab</code>命令进入并编辑定时任务。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">*/1 * * * *     root   /bin/sh /opt/node_server/public/project/bianli.sh</div></pre></td></tr></table></figure></p>
<p>前面部分是定时任务的频率，最后部分是要执行的脚本。</p>
<h4 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a><a href="https://github.com/ZhangShuangV/getWebsite" target="_blank" rel="external">github地址</a></h4>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodejs简易爬虫实现]]></title>
      <url>http://zhangshuang.top/nodejs%E7%AE%80%E6%98%93%E7%88%AC%E8%99%AB%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>通过nodejs抓取特定页面的特定内容，并且写入文件中。<br>demo很简单，注释也很完善，很好理解。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">var request = require(&apos;request&apos;); //请求模块，</div><div class="line">var cheerio = require(&apos;cheerio&apos;); //相当于jQuery</div><div class="line">var fs = require(&apos;fs&apos;); //nodejs的文件模块File System</div><div class="line"></div><div class="line">function getHtml(url) &#123;</div><div class="line">    request(url, function (error, response, body) &#123;</div><div class="line">        if (!error &amp;&amp; response.statusCode == 200) &#123;</div><div class="line">            var $ = cheerio.load(body,&#123; //加载html</div><div class="line">                decodeEntities:false //禁止转码</div><div class="line">            &#125;);</div><div class="line">            $(&quot;div.arcBody&gt;p&quot;).each(function () &#123; //这个地方需要根据目标页面修改</div><div class="line">                var content = $(this).text(); //获取抓取的信息</div><div class="line">                fs.appendFileSync(&apos;yikedou.txt&apos;,content); //这里只是简单的添加进了txt文件中，需要样式的，直接加入标签在写入文件即可。</div><div class="line">            &#125;);</div><div class="line">            var prevArcLink = $(&quot;div.prevNextArc&gt;span#prevArcLink&gt;a&quot;).attr(&quot;href&quot;); //获取地址</div><div class="line">            var realPrevArcLink = site + prevArcLink; //因为该网站的地址不是带域名的绝对路径，所以这里要将网站的域名加上，应具体问题具体修改</div><div class="line">            getHtml(realPrevArcLink); //递归，将真实路径传入，递归抓取</div><div class="line">            // fs.appendFileSync(&apos;yikedou.txt&apos;,cnt)</div><div class="line">        &#125; else&#123;</div><div class="line">            console.log(error,response.statusCode);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var site = &quot;http://www.yikedou.com&quot;; //目标页面的域名</div><div class="line">var firstUrl = &apos;http://www.yikedou.com/wenzi/201510/48767.html&apos;; //第一次要抓取的页面</div><div class="line"></div><div class="line">getHtml(firstUrl); //执行</div></pre></td></tr></table></figure></p>
<h4 id="github地址"><a href="#github地址" class="headerlink" title="github地址"></a><a href="https://github.com/ZhangShuangV/crawler" target="_blank" rel="external">github地址</a></h4><a id="more"></a>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[将ipad扩展为第二屏幕]]></title>
      <url>http://zhangshuang.top/%E5%B0%86ipad%E6%89%A9%E5%B1%95%E4%B8%BA%E7%AC%AC%E4%BA%8C%E5%B1%8F%E5%B9%95/</url>
      <content type="html"><![CDATA[<h5 id="将ipad扩展为第二屏幕"><a href="#将ipad扩展为第二屏幕" class="headerlink" title="将ipad扩展为第二屏幕"></a>将ipad扩展为第二屏幕</h5><p>前几天将家里的ipad翻出来，想看看能不能作为电脑的扩展屏来使用。然后就上网找各种资料破解之类的。试了好多种办法，现在将我找到的办法分享出来，亲测可用:  </p>
<h6 id="前提"><a href="#前提" class="headerlink" title="前提:"></a>前提:</h6><ol>
<li>需要一个ipad，我的是ipad air2。</li>
<li>ios端需要安装idisplay（pp助手搜索idisplay，下载即可）。</li>
<li>window也需要<a href="http://www.ddooo.com/softdown/21535.htm" target="_blank" rel="external">安装idisplay</a>。<a id="more"></a>
</li>
</ol>
<h6 id="过程"><a href="#过程" class="headerlink" title="过程:"></a>过程:</h6><ol>
<li>在ipad上安装好下载的idisplay。</li>
<li>在电脑上安装idisplay，虽然是英文但不影响，选择好安装磁盘，一路next。</li>
<li>保证你的电脑和ipad连接在同一路由器上（如果是笔记本可以创建一个无线热点，让ipad接入，如果不会自己百度一下）。</li>
<li>在windows上运行idisplay，（用管理员身份运行），此时在桌面右下角的任务栏上会出现一个灰色的图标。</li>
<li>在ipad上运行idisplay，会自动搜索出你的电脑，选择即可。</li>
<li>准备工作完成。<h6 id="用法"><a href="#用法" class="headerlink" title="用法:"></a>用法:</h6>用法：在电脑上将窗口拖向屏幕右侧，奇迹出现了！这个窗口会在ipad上出现！用鼠标即可在ipad上操作，也可触摸操作！相信大家一看就会。<br>教程到此结束，此功能操作简单，新颖，值得尝试。大家别忘了顶一下，谢谢</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分享几个关于时间的操作]]></title>
      <url>http://zhangshuang.top/%E5%88%86%E4%BA%AB%E5%87%A0%E4%B8%AA%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<h4 id="分享几个与时间有关的操作"><a href="#分享几个与时间有关的操作" class="headerlink" title="分享几个与时间有关的操作"></a>分享几个与时间有关的操作</h4><ol>
<li>获取当前时间的毫秒数:<br><code>new Date().getTime();
+new Date();</code></li>
<li>确定是不是在某个时间段:<a id="more"></a>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function isInTime(now) &#123;</div><div class="line">    const hours = new Date(now).getHours();</div><div class="line">    if(hours &gt;= 9 &amp;&amp; hours &lt;= 15) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;else &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为公司是做人工智能投顾的，与股票相关，所以这里时间段直接写的9–15。如果想改变的话可以改成将时间段也传入，并做相应修改。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function isInTime(now, before = 9, after = 15) &#123;</div><div class="line">    const hours = new Date(now).getHours();</div><div class="line">    if(hours &gt;= before &amp;&amp; hours &lt;= after) &#123;</div><div class="line">        return true;</div><div class="line">    &#125;else &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.日期之间的运算，并格式化:<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function dateFormat(m, d, numDate, symbol = &quot;:&quot;) &#123;</div><div class="line">    var date = null;</div><div class="line">    if(!numDate) &#123; //如果没有传入numDate</div><div class="line">        date = +new Date(); //获取当前时间的毫秒数</div><div class="line">        date = date + d * 24 * 60 * 60 * 1000; //将date赋值为当前时间毫秒数+传入天数（d）点击毫秒数</div><div class="line">        date = new Date(date); //再将其转换为标准时间。</div><div class="line"></div><div class="line">        var yy = date.getFullYear();</div><div class="line">        var mm = date.getMonth();</div><div class="line">        var dd = date.getDate();</div><div class="line">        if(mm === 0 &amp;&amp; m === -1) &#123;</div><div class="line">            mm = 11;</div><div class="line">            yy = yy - 1;</div><div class="line">        &#125;else &#123;</div><div class="line">            mm = mm + m;</div><div class="line">        &#125;</div><div class="line">    &#125;else &#123; //如果传入了numDate(毫秒数)，将其转变为制定格式的时间</div><div class="line">        date = new Date(numDate);</div><div class="line">        var yy = date.getFullYear();</div><div class="line">        var mm = date.getMonth();</div><div class="line">        var dd = date.getDate();</div><div class="line">    &#125;</div><div class="line">    return yy + symbol + (mm + 1) + symbol + dd;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodejs安装及常用快捷键]]></title>
      <url>http://zhangshuang.top/nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      <content type="html"><![CDATA[<h4 id="安装nvm，nodejs版本管理工具"><a href="#安装nvm，nodejs版本管理工具" class="headerlink" title="安装nvm，nodejs版本管理工具"></a>安装nvm，nodejs版本管理工具</h4><p><a href="https://github.com/creationix/nvm" target="_blank" rel="external">参考：https://github.com/creationix/nvm</a><br><a href="http://www.imooc.com/article/14617" target="_blank" rel="external">参考：http://www.imooc.com/article/14617</a><br><a href="https://www.vmvps.com/4-ways-to-install-node-js-on-centos-7-servers.html#nvm" target="_blank" rel="external">参考：centOs中安装nodejs</a></p>
<ol>
<li>通过curl安装nvm<br><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.32.1/install.sh | bash</code></li>
<li>设置环境变量<br><code>export NVM_DIR=&quot;$HOME/.nvm&quot;</code></li>
<li>load nvm<br><code>[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;</code>  <a id="more"></a></li>
<li>nvm命令行操作<ol>
<li>查看已经安装的nodejs版本<br><code>nvm list</code> / <code>nvm ls</code></li>
<li>查看nvm版本<br><code>nvm --version</code>  </li>
<li>切换版本，仅限下载过的node版本<br><code>nvm use &lt;version&gt;</code>例:<code>nvm use v4.7.0</code>  </li>
<li>设定默认node版本<br><code>nvm alias default &lt;version&gt;</code>例:<code>nvm alias default v4.7.0</code>  </li>
</ol>
</li>
</ol>
<p>##</p>
<h4 id="通过nvm安装nodejs"><a href="#通过nvm安装nodejs" class="headerlink" title="通过nvm安装nodejs"></a>通过nvm安装nodejs</h4><ol>
<li>安装6.x版本<br><code>nvm install 6</code></li>
<li>安装4.x版本<br><code>nvm install 4</code>  </li>
<li>查看node所有版本<br><code>nvm ls-remote</code>  </li>
<li>安装位置<br><code>~/.nvm/versions/node</code><br><code>/Users/zhangshuang/.nvm/versions/node</code><br>##</li>
</ol>
<h4 id="npm淘宝镜像-cnpm"><a href="#npm淘宝镜像-cnpm" class="headerlink" title="npm淘宝镜像 cnpm"></a>npm淘宝镜像 cnpm</h4><ol>
<li>安装:<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </li>
<li><p>使用：<br><code>cnpm install -g &lt;packageName&gt;</code>例:<code>cnpm install -g nodemon</code>  </p>
</li>
<li><p>设置：npm配置信息<br><code>npm config list</code>  </p>
</li>
<li>设置：npm registry 设置镜像路径<br><code>npm config set registry  &quot;https://registry.npmjs.org/&quot;</code>  </li>
</ol>
<h4 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h4><p><a href="http://blog.unieagle.net/2012/05/21/linux%E4%B8%8B%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4alias%EF%BC%8C%E5%B9%B6%E4%BF%9D%E5%AD%98%E5%88%AB%E5%90%8D%E4%BD%BF%E5%85%B6%E6%B0%B8%E4%B9%85%E7%94%9F%E6%95%88%EF%BC%88%E9%87%8D/" target="_blank" rel="external">alias设置别名</a></p>
<ol>
<li>原因：简化命令行提交代码的复杂度  </li>
<li>方法：<code>vim ~/.bashrc</code>进入该文件  </li>
<li>新增：<code>alias &lt;name&gt;=&#39;&lt;yourcode&gt;&#39;</code>例:<code>alias myweb=&#39;ssh -p 3000 root@192.169.21.141&#39;</code>  </li>
<li>生效：<code>source ~/.bashrc</code>  </li>
<li>使用：<code>myweb</code> + Enter</li>
<li>如果未生效，创建<code>~/.bash_profile</code>，该文件是用户登录终端时自动执行的文件，一般此文件中会调用.bashrc，在其中写入<code>source ~/.bashrc</code><br>##</li>
</ol>
<h4 id="pm2-与-nodemon"><a href="#pm2-与-nodemon" class="headerlink" title="pm2 与 nodemon"></a>pm2 与 nodemon</h4><h5 id="nodemon，开发环境使用，检测script文件变化，自动重启服务器"><a href="#nodemon，开发环境使用，检测script文件变化，自动重启服务器" class="headerlink" title="nodemon，开发环境使用，检测script文件变化，自动重启服务器"></a>nodemon，<em>开发环境使用</em>，检测script文件变化，自动重启服务器</h5><ol>
<li>安装：<br><code>npm install -g nodemon</code></li>
<li>运行：<br><code>nodemon &lt;appName&gt;</code>例:<code>nodemon app.js</code>  </li>
<li>更改默认端口<br><code>nodemon &lt;appName&gt; localhost 8080</code></li>
</ol>
<h5 id="pm2，生产环境使用，服务器崩溃自动重启"><a href="#pm2，生产环境使用，服务器崩溃自动重启" class="headerlink" title="pm2，生产环境使用，服务器崩溃自动重启"></a>pm2，<em>生产环境使用</em>，服务器崩溃自动重启</h5><ol>
<li>安装：<br><code>npm install -g pm2</code>   </li>
<li>运行<br><code>pm2 start &lt;appName&gt;</code>例:<code>pm2 start server.js</code><br><strong>使用多核心</strong><code>pm2 start &lt;appName&gt; -i max</code></li>
<li>查看已启动的应用列表<br><code>pm2 list</code>  </li>
<li>查看应用详情<br><code>pm2 show &lt;appName&gt;</code>例:<code>pm2 show server.js</code></li>
<li>退出pm2<br><code>pm2 kill</code></li>
<li>查看控制台输出<br><code>pm2 logs &lt;appName?&gt;</code>输入app名可查看单个输出</li>
<li>关闭某个进程<br><code>pm2 stop &lt;id&gt;</code>例:<code>pm2 stop 0</code>  </li>
<li>重启应用<br><code>pm2 restart &lt;appName&gt;</code>例:<code>pm2 restart server.js</code>  </li>
<li>重载应用<br><code>pm2 reload &lt;appName&gt;</code>例:<code>pm2 reload server.js</code>  </li>
<li>停止应用<br><code>pm2 stop &lt;appName&gt;</code>例:<code>pm2 stop server.js</code>  </li>
<li>将应用从pm2中删除<br><code>pm2 delete &lt;appName&gt;</code>例:<code>pm2 delete server.js</code>   </li>
<li>命名应用<br><code>pm2 start server.js --name game</code>  </li>
<li>复合运用，命名、最多核心运行<br><code>pm2 start server.js --name game -i max</code><br><code>pm2 start server.js --name localGameServer -i max --watch</code>  </li>
<li>监控<br><code>pm2 monit</code>  </li>
</ol>
<p><a href="http://imweb.io/topic/57c8cbb27f226f687b365636" target="_blank" rel="external">参考：PM2实用入门指南</a><br><a href="https://www.zybuluo.com/zhenxi/note/512949" target="_blank" rel="external">参考：生产环境部署pm2</a>  </p>
<p>##</p>
<h4 id="express-web开发框架"><a href="#express-web开发框架" class="headerlink" title="express web开发框架"></a>express web开发框架</h4><ol>
<li>安装express：<br><code>sudo npm install -g express</code></li>
<li>安装express命令行工具：<br><code>sudo npm install -g express-generator</code></li>
<li>启动：<br><code>npm start</code><br>##</li>
</ol>
<h4 id="node"><a href="#node" class="headerlink" title="node"></a>node</h4><ol>
<li>运行进程 <code>node</code>  </li>
<li>退出进程 <code>process.exit()</code>  </li>
<li>查看进程pid <code>global.process.pid</code>  </li>
<li>设置作者  <code>npm config get init-author-name</code>  </li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[highcharts绘制环形配比图]]></title>
      <url>http://zhangshuang.top/highcharts%E7%BB%98%E5%88%B6%E7%8E%AF%E5%BD%A2%E9%85%8D%E6%AF%94%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h4 id="highcharts绘制k线的常用配置"><a href="#highcharts绘制k线的常用配置" class="headerlink" title="highcharts绘制k线的常用配置"></a>highcharts绘制k线的常用配置</h4><h5 id="之前看的都是中文文档，绘制环形配比图这个需求采用highcharts，想挑战一下自己，看一下英文的文档，结果苦逼的挨个敲出来试看是什么东西…"><a href="#之前看的都是中文文档，绘制环形配比图这个需求采用highcharts，想挑战一下自己，看一下英文的文档，结果苦逼的挨个敲出来试看是什么东西…" class="headerlink" title="之前看的都是中文文档，绘制环形配比图这个需求采用highcharts，想挑战一下自己，看一下英文的文档，结果苦逼的挨个敲出来试看是什么东西…"></a>之前看的都是中文文档，绘制环形配比图这个需求采用highcharts，想挑战一下自己，看一下英文的文档，结果苦逼的挨个敲出来试看是什么东西…</h5><p>中文的api也有很多，现在将自己的代码贴出来，省的以后哪天想用的时候还要再过一遍，里面基本都写了注释，普通的需求基本都满足了。之后再分享一篇关于k线的配置。<br><a id="more"></a></p>
<p><img src="https://ooo.0o0.ooo/2017/01/09/58739e20046ee.png" alt="效果图"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">$(&quot;#container&quot;).highcharts(&#123;</div><div class="line">    chart: &#123; //图表整体设置</div><div class="line">        type: &quot;pie&quot; //图表样式为饼图</div><div class="line">    &#125;,</div><div class="line">    title: &#123; //图表标题设置</div><div class="line">        text: &apos;&lt;span style=&quot;color:#333333;font-size:.33rem;&quot;&gt;&apos; + ismDuring + &apos;天&lt;/span&gt;&lt;br/&gt;&apos;,</div><div class="line">        verticalAlign: &quot;top&quot;,</div><div class="line">        align: &quot;left&quot;,</div><div class="line">        x: 0.92 * FS,</div><div class="line">        y: 1.34 * FS</div><div class="line">    &#125;,</div><div class="line">    subtitle: &#123; //图表副标题设置</div><div class="line">        text: &apos;&lt;span style=&quot;font-size:.24rem;text-align:center;color:#979797;&quot;&gt;运作期&lt;/span&gt;&apos;,</div><div class="line">        verticalAlign: &quot;top&quot;,</div><div class="line">        align: &quot;left&quot;,</div><div class="line">        x: 0.92 * FS,</div><div class="line">        y: 1.78 * FS</div><div class="line">    &#125;,</div><div class="line">    plotOptions: &#123; //图表</div><div class="line">        pie: &#123;</div><div class="line">            center: [0.9 * FS, 1 * FS],</div><div class="line">            allowPointSelect: false,</div><div class="line">            showInLegend: true, //是否显示图例</div><div class="line">            ignoreHiddenPoint: true,</div><div class="line">            size: 2.5 * FS, //饼图的大小</div><div class="line">            innerSize: 2.16 * FS, //圆环的大小</div><div class="line">            colors: [ //圆环颜色，如果数据多于颜色的个数，则颜色会重复出现</div><div class="line">                &quot;#df4935&quot;, &quot;#f38f28&quot;, &quot;#e9da59&quot;, &quot;#73d84b&quot;, &quot;#3adfd2&quot;, &quot;#20acff&quot;, &quot;#275caa&quot;, &quot;#8d84f0&quot;</div><div class="line">            ],</div><div class="line">            dataLabels: &#123;</div><div class="line">                enabled: false //图表区块的解释，小黑线伸出来的部分</div><div class="line">            &#125;,</div><div class="line">            point: &#123;</div><div class="line">                events: &#123;</div><div class="line">                    legendItemClick: function() &#123;</div><div class="line">                        return false; //图表的legend是否可以点击，如果可以 点击则取消</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        series: &#123;</div><div class="line">            allowPointSelect: true, //click的时候能否移出来</div><div class="line">            enableMouseTracking: true //hover到饼上面不显示外宽</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    legend: &#123; //图例</div><div class="line">        layout: &quot;vertical&quot;, //图例布局： 垂直排列,</div><div class="line">        verticalAlign: &quot;middle&quot;,</div><div class="line">        align: &quot;right&quot;,</div><div class="line">        y: 0 * FS,</div><div class="line">        x: 0 * FS,</div><div class="line">        labelFormatter: function() &#123; //图例显示的内容</div><div class="line">            return &apos;&lt;span style=&quot;width:1.55rem;display:inline-block;font-size:.18rem;color:#666666;font-weight:100;&quot;&gt;&apos; + this.name + &apos;&lt;/span&gt;&lt;span style=&quot;color:#666666;font-weight:100;font-size:.18rem;&quot;&gt;&apos; + this.percentage.toFixed(2) + &apos;%&lt;/span&gt;&apos;</div><div class="line">        &#125;,</div><div class="line">        useHTML: true,</div><div class="line">        itemWidth: 3.5 * FS,</div><div class="line">        symbolWidth: 0.16 * FS,</div><div class="line">        symbolHeight: 0.16 * FS,</div><div class="line">        rtl: false //图表是否在右边</div><div class="line">    &#125;,</div><div class="line">    tooltip: &#123; //提示框</div><div class="line">        enabled: false,</div><div class="line">        headerFormat: &apos;&lt;span style=&quot;font-size:11px&quot;&gt;&#123;series.name&#125;&lt;/span&gt;&lt;br&gt;&apos;,</div><div class="line">        pointFormat: &apos;&lt;span style=&quot;color:&#123;point.color&#125;&quot;&gt;&#123;point.name&#125;&lt;/span&gt;: &lt;b&gt;&#123;point.y:.2f&#125;%&lt;/b&gt;&lt;br/&gt;&apos;</div><div class="line">    &#125;,</div><div class="line">    credits: &#123;</div><div class="line">        enabled: false</div><div class="line">    &#125;,</div><div class="line">    series: [ //数据</div><div class="line">        &#123;</div><div class="line">            name: &quot;推荐策略&quot;,</div><div class="line">            colorByPoint: true,</div><div class="line">            data: filterJson(data)</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[整理几个移动端的兼容性问题]]></title>
      <url>http://zhangshuang.top/%E6%95%B4%E7%90%86%E5%87%A0%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h4 id="还是前几天谈的移动端问题，这次说一下项目中遇到的几个移动端兼容性问题"><a href="#还是前几天谈的移动端问题，这次说一下项目中遇到的几个移动端兼容性问题" class="headerlink" title="还是前几天谈的移动端问题，这次说一下项目中遇到的几个移动端兼容性问题"></a>还是前几天谈的移动端问题，这次说一下项目中遇到的几个移动端兼容性问题</h4><h5 id="一-华为荣耀3C的原生浏览器问题："><a href="#一-华为荣耀3C的原生浏览器问题：" class="headerlink" title="一. 华为荣耀3C的原生浏览器问题："></a>一. 华为荣耀3C的原生浏览器问题：</h5><p>同一行内，存在靠左与靠右的元素时，都必须加上浮动，否则，右浮元素不右浮，影响后续排版。<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;div class=&quot;forcast-title&quot;&gt;</div><div class="line">    &lt;span class=&quot;fl&quot;&gt;上一交易日预报结果&lt;/span&gt;</div><div class="line">    &lt;span class=&quot;fr gray&quot;&gt;2016-03-04&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;div class=&quot;forcast-cnt ofh gray cb&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>两个行内元素span元素都要浮动才行。</p>
<h5 id="二-ios-safari时间显示问题。"><a href="#二-ios-safari时间显示问题。" class="headerlink" title="二. ios safari时间显示问题。"></a>二. ios safari时间显示问题。</h5><p>之前设置new Date日期格式的时候，在ios中的safari中发现显示效果与其他浏览器不一致，找了多方面原因，结果是把“-”换成“/”就可以解决了。<code>new Date(&quot;year-month-day&quot;);</code>只识别<code>new Date(&quot;year/month/day&quot;);</code></p>
<h5 id="三-关于长按识别二维码问题。"><a href="#三-关于长按识别二维码问题。" class="headerlink" title="三. 关于长按识别二维码问题。"></a>三. 关于长按识别二维码问题。</h5><p>安卓设备微信中识别没问题，结果到了ios中识别不了。最终发现是将position设置为fixed，ios的微信中长按会不起作用。要想在ios的微信中实现长按识别二维码，只需确保二维码图片和包住图片的div都没有设置<code>position:fiexd</code>即可。</p>
<h5 id="四-移动端最小识别rem问题。"><a href="#四-移动端最小识别rem问题。" class="headerlink" title="四. 移动端最小识别rem问题。"></a>四. 移动端最小识别rem问题。</h5><p>移动端相对来说兼容性不是什么问题，但是实际项目中发现，如果采用<code>rem: .01rem;</code>有些机型如：魅蓝note、iphone5等机型的webview中显示不出来。华为荣耀有的设置border的时候，有时0.03rem可以，有时不可以，暂时不明所以。所以还是建议，像border这种属性，移动端可以设置为1px。</p>
<h5 id="五-点击跳转到新页面会有类似点击穿透效果。"><a href="#五-点击跳转到新页面会有类似点击穿透效果。" class="headerlink" title="五. 点击跳转到新页面会有类似点击穿透效果。"></a>五. 点击跳转到新页面会有类似点击穿透效果。</h5><p>部分机型（三星note2、htc one …）在app的webview中出现了点击链接跳转到下一页面后，如果要跳转页面在当前页面的按钮位置有a链接的话，会出现，点击当前页面链接，直接也点击了下一页吗的链接。<br>可能描述的不是很清楚，更形象点说。A页面有个链接a，B页面也有个链接b，并且b的x、y属性含于a的x、y属性。那么会出现点击a链接，直接也点击了b链接。<br>解决办法，直接在另一个页面写了个maskView遮罩层，setTimeout100毫秒解决的。可能有点low，但是当时上线较急，就想到了这个办法。</p>
<h5 id="六-让hybird-app中的webview页面看起来更像native。"><a href="#六-让hybird-app中的webview页面看起来更像native。" class="headerlink" title="六. 让hybird app中的webview页面看起来更像native。"></a>六. 让hybird app中的webview页面看起来更像native。</h5><p>web相较于native有一个好处就是版本更新比较方便，不会出现native应用商店审核乱七八糟的时间，直接点击app的某个按钮，使用webview打开页面，该页面随意替换都非常方便。最常用的就是活动页面，定期的活动只需要前端开发人员维护即可。但是假如用户长按屏幕的时候出现选中文本的场景，看起来不那么想native，如果有解决这个问题的需求，可使用：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">Element &#123;</div><div class="line">    -webkit-user-select: none;</div><div class="line">    -moz-user-select: none;</div><div class="line">    -khtml-user-select: none;</div><div class="line">    user-select: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中Element为任意元素，或者直接将其写入cssReset文件中。</p>
<h5 id="七-移动端300ms延迟。"><a href="#七-移动端300ms延迟。" class="headerlink" title="七. 移动端300ms延迟。"></a>七. 移动端300ms延迟。</h5><p>300ms尚可接受，不过因为300ms产生的问题，我们必须要解决。300ms导致用户体验并不是很好，解决这个问题，我们一般在移动端用tap事件来取代click事件。<br>推荐两个js，一个是fastclick，一个是tap.js<br>关于300ms延迟，具体<a href="http://thx.github.io/mobile/300ms-click-delay/" target="_blank" rel="external">请看</a></p>
<h5 id="八-移动端-HTML5-audio-autoplay-失效问题"><a href="#八-移动端-HTML5-audio-autoplay-失效问题" class="headerlink" title="八. 移动端 HTML5 audio autoplay 失效问题"></a>八. 移动端 HTML5 audio autoplay 失效问题</h5><p>这个不是 BUG，由于自动播放网页中的音频或视频，会给用户带来一些困扰或者不必要的流量消耗，所以苹果系统和安卓系统通常都会禁止自动播放和使用 JS 的触发播放，必须由用户来触发才可以播放。<br>解决方法思路：先通过用户 touchstart 触碰，触发播放并暂停（音频开始加载，后面用 JS 再操作就没问题了）。<br>解决代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">document.addEventListener(&apos;touchstart&apos;, function () &#123;</div><div class="line">    document.getElementsByTagName(&apos;audio&apos;)[0].play();</div><div class="line">    document.getElementsByTagName(&apos;audio&apos;)[0].pause();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h5 id="九-根据屏幕大小加载不同js"><a href="#九-根据屏幕大小加载不同js" class="headerlink" title="九. 根据屏幕大小加载不同js"></a>九. 根据屏幕大小加载不同js</h5><p>之前话k线用到highcharts的时候，在iphone5上发现显示不是很理想，用过highchars的api设置也没有解决一次设定适应多个屏幕。于是只能用过这种方式来进行多屏幕的适配。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var browserWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;</div><div class="line">    var script = document.createElement(&quot;script&quot;);</div><div class="line">    if(browserWidth &lt;= 380) &#123;</div><div class="line">        script.src = &quot;js/common_small.js&quot;</div><div class="line">    &#125;else&#123;</div><div class="line">        script.src = &quot;js/common.js&quot;</div><div class="line">    &#125;</div><div class="line">    document.head.appendChild(script);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<h5 id="十-屏幕旋转的事件和样式"><a href="#十-屏幕旋转的事件和样式" class="headerlink" title="十.  屏幕旋转的事件和样式"></a>十.  屏幕旋转的事件和样式</h5><p>事件名：window.orientation，取值：正负90表示横屏模式，0和180表示竖屏模式。<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">window.onorientationchange = function()&#123;</div><div class="line">    switch(window.orientation)&#123;</div><div class="line">        case -90:</div><div class="line">        case 90:</div><div class="line">        alert(&quot;横屏:&quot; + window.orientation);</div><div class="line">        case 0:</div><div class="line">        case 180:</div><div class="line">        alert(&quot;竖屏:&quot; + window.orientation);</div><div class="line">        break;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有些地方发现屏幕旋转之后，样式适配不完美，所以根据上面的orientation事件，增加了监测到设备屏幕旋转自动刷新的功能：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">function hengshuping()&#123;</div><div class="line">	window.location.reload();</div><div class="line">&#125;</div><div class="line">window.addEventListener(&quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;, hengshuping, false);</div></pre></td></tr></table></figure></p>
<h5 id="十一-background-size问题："><a href="#十一-background-size问题：" class="headerlink" title="十一. background-size问题："></a>十一. background-size问题：</h5><p>华为p8，魅族自带浏览器background-size显示有问题。</p>
<h5 id="十二-flex布局问题："><a href="#十二-flex布局问题：" class="headerlink" title="十二. flex布局问题："></a>十二. flex布局问题：</h5><p>iphone5s、魅族魅蓝note不支持(具体是自带浏览器还是什么浏览器忘了，有需要的可以自己尝试一下)</p>
<h5 id="十三-input输入框的问题"><a href="#十三-input输入框的问题" class="headerlink" title="十三. input输入框的问题"></a>十三. input输入框的问题</h5><p>最开始在input输入框中，也会习惯性的写上lineheight（其实可以不写），当使用placeholder的时候自己测试也没有问题。但当测试用魅族mx4自带浏览器测试的时候发现，在input输入框中，输入光标不会上下居中。当时也感觉很奇怪，然而将lineheight删掉就可以了，input中的所有元素就是默认居中的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[通过Html网页调用本地安卓app程序代码]]></title>
      <url>http://zhangshuang.top/%E9%80%9A%E8%BF%87Html%E7%BD%91%E9%A1%B5%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%8D%93(android)app%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/</url>
      <content type="html"><![CDATA[<h4 id="前段时间写一些移动端的项目，正好项目中遇到与native交互的需求，特此将其整理下来："><a href="#前段时间写一些移动端的项目，正好项目中遇到与native交互的需求，特此将其整理下来：" class="headerlink" title="前段时间写一些移动端的项目，正好项目中遇到与native交互的需求，特此将其整理下来："></a>前段时间写一些移动端的项目，正好项目中遇到与native交互的需求，特此将其整理下来：</h4><h5 id="一-通过html页面打开Android本地的app"><a href="#一-通过html页面打开Android本地的app" class="headerlink" title="一. 通过html页面打开Android本地的app"></a>一. 通过html页面打开Android本地的app</h5><ol>
<li><p>首先在编写一个简单的html页面</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">        &lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;a href=&quot;m://my.com/&quot;&gt;打开app&lt;/a&gt;&lt;br/&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>在Android本地app的配置<br>在AndroidManifest的清单文件里的intent-filte中加入如下元素：</p>
<a id="more"></a>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;intent-filter&gt;</div><div class="line">&lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;</div><div class="line">                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;</div><div class="line">                &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;</div><div class="line">                &lt;data</div><div class="line">                    android:host=&quot;my.com&quot;</div><div class="line">                    android:scheme=&quot;m&quot; /&gt;</div><div class="line">&lt;/intent-filter&gt;</div></pre></td></tr></table></figure>
<p>然后使用“手机浏览器”或者“webview”的方式打开这个本地的html网页，点击“打开APP”即可成功开启本地的指定的app</p>
<h5 id="二、如何通过这个方法获取网页带过来的数据"><a href="#二、如何通过这个方法获取网页带过来的数据" class="headerlink" title="二、如何通过这个方法获取网页带过来的数据"></a>二、如何通过这个方法获取网页带过来的数据</h5><p>只能打开就没什么意思了，最重要的是，我们要传递数据，那么怎么去传递数据呢？<br>我们可以使用上述的方法，把一些数据传给本地app，那么首先我们更改一下网页，代码修改后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;</div><div class="line">        &lt;title&gt;Insert title here&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;a href=&quot;m://my.com/?arg0=0&amp;arg1=1&quot;&gt;打开app&lt;/a&gt;&lt;br/&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure></p>
<p>（1）.假如你是通过浏览器打开这个网页的，那么获取数据的方式为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">uri = getIntent().getData();  String test1= uri.getQueryParameter(&quot;arg0&quot;);  String test2= uri.getQueryParameter(&quot;arg1&quot;);</div></pre></td></tr></table></figure></p>
<p>（2）如果使用webview访问该网页，获取数据的操作为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">webView.setWebViewClient(new WebViewClient()&#123;</div><div class="line">  @Override</div><div class="line">  public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</div><div class="line">      Uri uri=Uri.parse(url);</div><div class="line">          if(uri.getScheme().equals(&quot;m&quot;)&amp;&amp;uri.getHost().equals(&quot;my.com&quot;))&#123;</div><div class="line">              String arg0=uri.getQueryParameter(&quot;arg0&quot;);</div><div class="line">              String arg1=uri.getQueryParameter(&quot;arg1&quot;);</div><div class="line"></div><div class="line">          &#125;else&#123;</div><div class="line">              view.loadUrl(url);</div><div class="line">          &#125;</div><div class="line">      return true;</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
  
  
    
    <entry>
      <title></title>
      <url>http://zhangshuang.top/README.html</url>
      <content type="html"><![CDATA[<h2 id="个人博客目录"><a href="#个人博客目录" class="headerlink" title="个人博客目录"></a>个人博客目录</h2><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><p><a href="http://www.zhangshuang.top/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E7%A7%80%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E8%AE%BE%E8%AE%A1/" target="_blank" rel="external">什么是优秀的用户界面设计</a></p>
<h4 id="egret引擎"><a href="#egret引擎" class="headerlink" title="egret引擎"></a>egret引擎</h4><p><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（一）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（二）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（三）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E5%9B%9B%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（四）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%BA%94%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（五）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E5%85%AD%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（六）</a><br><a href="http://www.zhangshuang.top/egret%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%83%EF%BC%89/" target="_blank" rel="external">egret游戏引擎（七）</a>  </p>
<h4 id="typescript"><a href="#typescript" class="headerlink" title="typescript"></a>typescript</h4><p><a href="http://www.zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">TypeScript(一)</a><br><a href="http://www.zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/" target="_blank" rel="external">TypeScript(二)</a><br><a href="http://www.zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E4%B8%89%EF%BC%89/" target="_blank" rel="external">TypeScript（三）</a><br><a href="http://www.zhangshuang.top/TypeScript%E5%88%9D%E8%AF%95%EF%BC%88%E5%9B%9B%EF%BC%89%20/" target="_blank" rel="external">TypeScript（四）</a>  </p>
<h4 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h4><p><a href="http://www.zhangshuang.top/nodejs%E5%AE%89%E8%A3%85%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" target="_blank" rel="external">nodejs安装及常用快捷键</a><br><a href="https://github.com/ZhangShuangV/getWebsite" target="_blank" rel="external">nodejs自动获取服务器文件</a><br><a href="https://github.com/ZhangShuangV/crawler" target="_blank" rel="external">nodejs爬虫</a>  </p>
<h4 id="Draw"><a href="#Draw" class="headerlink" title="Draw"></a>Draw</h4><p><a href="http://www.zhangshuang.top/highcharts%E7%BB%98%E5%88%B6k%E7%BA%BF/" target="_blank" rel="external">highcharts绘制环形配比图设置</a>  </p>
<h4 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h4><p><a href="http://www.zhangshuang.top/%E6%95%B4%E7%90%86%E5%87%A0%E4%B8%AA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98/" target="_blank" rel="external">整理几个移动端的兼容性问题</a><br><a href="http://www.zhangshuang.top/%E9%80%9A%E8%BF%87Html%E7%BD%91%E9%A1%B5%E8%B0%83%E7%94%A8%E6%9C%AC%E5%9C%B0%E5%AE%89%E5%8D%93app%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/" target="_blank" rel="external">通过Html网页调用本地安卓(android)app程序代码</a>  </p>
<h4 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h4><p><a href="http://www.zhangshuang.top/%E5%B0%86ipad%E6%89%A9%E5%B1%95%E4%B8%BA%E7%AC%AC%E4%BA%8C%E5%B1%8F%E5%B9%95/" target="_blank" rel="external">将iPad扩展为第二屏幕</a>  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[读书]]></title>
      <url>http://zhangshuang.top/reading/index.html</url>
      <content type="html"><![CDATA[<p>hi</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于]]></title>
      <url>http://zhangshuang.top/about/index.html</url>
      <content type="html"><![CDATA[<p>我叫张爽，91年出生，山东人。  </p>
<p>小的时候很调，长大了很老实。  </p>
<p>大学在山西长治上的，专业是舞蹈学… 当时还经常参加校内外的各种演出活动及主持人工作。之后也带个很多课，从幼儿园到成人…  </p>
<p>在校期间，有幸入选“中国——马来西亚马来亚大学交换生计划”，在大马学习生活过一段时间。    </p>
<p>毕业后因女朋友考研到青岛，遂去青岛工作两年，14年入职（金融公司），应聘的是业务，干了没几天就因公司需要，跟另一个小伙伴还是琢磨前端。其中各种问题，各种郁闷，当然也有收获。这期间也是什么都干，公司人少让出去帮忙搞活动，也去；让去开会，也去；让去参加培训，也去；总之，这段经历对我帮助很大。  </p>
<p>到16年，女朋友从山科大毕业，两人一合计，年轻的时候不作一下，年老的时候可能会悔恨。遂一同到北京发展。个人对待感情非常专一，与她已相爱接近六年（工作肯定也很专一了…）。  </p>
<p>主要技术方向是web前端，后端什么class、静态方法什么、单例模式还知道一二，其他的不大了解。人总归是要交流、要进步，还望网友们不吝指导。  </p>
<p>个人爱好广泛，小学时学过二胡（7级）、足球（守门员）、篮球（高中时期比较痴迷）、游泳健身（在大马交换期间隔天游泳隔天健身，在青岛的时候，夏天周末就游到防鲨网几个来回）。最近没大有时间锻炼，身体素质下降很多，争取在稳定下来之后，再寻找个游泳馆锻炼一下。其他的都属于菜鸟水准，欢迎网友们凑不齐人的时候call我。  </p>
<p>QQ: 547258574<br>Phone: 15711288669<br>Address: 北京朝阳望京<br>WeChat: 二维码 <img src="https://ooo.0o0.ooo/2017/02/08/589b3fdd81701.png" alt="二维码">     </p>
<p>感觉现在的自己冲劲有余，虽然社会阅历尚浅、资质尚薄，不过一切困难都是纸老虎 ：）  </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tags]]></title>
      <url>http://zhangshuang.top/tags/index.html</url>
      <content type="html"></content>
    </entry>
    
  
</search>
